.TH "Map<_K,  _V>" 3 "2018年 六月 29日 星期五" "Version 3.0" "xlang" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Map<_K,  _V> \- map容器  

.SH SYNOPSIS
.br
.PP
.SS "结构体"

.in +1c
.ti -1c
.RI "class \fBIterator\fP"
.br
.RI "\fImap的迭代器对象 \fP"
.in -1c
.SS "包函数"
.SH "详细描述"
.PP 
map容器 


.PP
\fB警告:\fP
.RS 4
_K 为非POD类型时需要重载 < > == != 操作符 
.RE
.PP

.PP
在文件 Map\&.xcs 第 6 行定义\&.
.SH "成员函数说明"
.PP 
.SS "void clear ()\fC [package]\fP"

.PP
清空容器 
.PP
\fB返回:\fP
.RS 4

.RE
.PP

.SS "bool containsKey (_K key)\fC [package]\fP"

.PP
测试是否包含某个key 
.PP
\fB返回:\fP
.RS 4
是/否 
.RE
.PP

.SS "_V get (_K key)\fC [package]\fP"

.PP
获取key对应的值 
.PP
\fB返回:\fP
.RS 4
值 
.RE
.PP

.SS "Iterator<_K, _V> iterator ()\fC [package]\fP"

.PP
获取迭代器 
.PP
\fB返回:\fP
.RS 4
迭代器 指向头部 
.RE
.PP

.SS "void put (_K key, _V val)\fC [package]\fP"

.PP
插入数据 
.PP
\fB返回:\fP
.RS 4

.RE
.PP

.SS "void remove (_K key)\fC [package]\fP"

.PP
从容器中删除某个键值对 
.PP
\fB返回:\fP
.RS 4

.RE
.PP

.SS "void remove (Iterator<_K, _V> iterator)\fC [package]\fP"

.PP
根据迭代器删除键值对 
.PP
\fB返回:\fP
.RS 4
长度 
.RE
.PP

.SS "int size ()\fC [package]\fP"

.PP
获取容器内数据数量 
.PP
\fB返回:\fP
.RS 4
长度 
.RE
.PP


.SH "作者"
.PP 
由 Doyxgen 通过分析 xlang 的 源代码自动生成\&.
