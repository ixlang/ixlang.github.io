.TH "String" 3 "2018年 六月 29日 星期五" "Version 3.0" "xlang" \" -*- nroff -*-
.ad l
.nh
.SH NAME
String \- 字符串类  

.SH SYNOPSIS
.br
.PP
.SS "包函数"
.SS "静态包函数"
.SH "详细描述"
.PP 
字符串类 


.PP
\fB警告:\fP
.RS 4
该对象一旦创建即不可改变 
.RE
.PP

.PP
在文件 String\&.xcs 第 7 行定义\&.
.SH "构造及析构函数说明"
.PP 
.SS "\fBString\fP (byte  [] data)\fC [package]\fP"

.PP
从byte数组构造一个string 
.PP
\fB参数:\fP
.RS 4
\fIdata\fP byte数组 
.RE
.PP

.SS "\fBString\fP (byte  [] data, int offset, int length)\fC [package]\fP"

.PP
从byte数组构造一个string 
.PP
\fB参数:\fP
.RS 4
\fIdata\fP byte数组 
.br
\fIoffset\fP data中的指针 
.br
\fIlength\fP 长度 
.RE
.PP

.SS "\fBString\fP (\fBString\fP text)\fC [package]\fP"

.PP
从String构造一个string 
.PP
\fB参数:\fP
.RS 4
\fItext\fP string对象 
.RE
.PP

.SH "成员函数说明"
.PP 
.SS "\fBString\fP append (\fBString\fP sub)\fC [package]\fP"

.PP
连接对象并产生新串 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以连接的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP append (char sub)\fC [package]\fP"

.PP
连接对象并产生新串 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以连接的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP appendPath (\fBString\fP str)\fC [package]\fP"

.PP
连接路径,该方法会按照平台使用不同的\\的/来连接路径串 
.PP
\fB参数:\fP
.RS 4
\fIstr\fP 子路径 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "int countChar (char c)\fC [package]\fP"

.PP
统计字符串中字符出现的次数 
.PP
\fB参数:\fP
.RS 4
\fIc\fP 字符 
.RE
.PP
\fB返回:\fP
.RS 4
计数 
.RE
.PP

.SS "int countString (\fBString\fP str)\fC [package]\fP"

.PP
统计字符串中另一个串出现的次数 
.PP
\fB参数:\fP
.RS 4
\fIstr\fP 另一个串 
.RE
.PP
\fB返回:\fP
.RS 4
计数 
.RE
.PP

.SS "int countStringIgnoreCase (\fBString\fP str)\fC [package]\fP"

.PP
统计字符串中另一个串(忽略大小写)出现的次数 
.PP
\fB参数:\fP
.RS 4
\fIstr\fP 另一个串 
.RE
.PP
\fB返回:\fP
.RS 4
计数 
.RE
.PP

.SS "bool endWith (\fBString\fP sub)\fC [package]\fP"

.PP
测试串是否由另一个字串结尾 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的串 
.RE
.PP
\fB返回:\fP
.RS 4
是/否 
.RE
.PP

.SS "bool equals (\fBString\fP other)\fC [package]\fP"

.PP
测试两个串是否相等 
.PP
\fB参数:\fP
.RS 4
\fIother\fP 另一个串 
.RE
.PP
\fB返回:\fP
.RS 4
比较结果 
.RE
.PP

.SS "bool equalsIgnoreCase (\fBString\fP other)\fC [package]\fP"

.PP
忽略大小写并比较两个串是否相等 
.PP
\fB参数:\fP
.RS 4
\fIother\fP 另一个串 
.RE
.PP
\fB返回:\fP
.RS 4
比较结果 
.RE
.PP

.SS "\fBString\fP escape ()\fC [package]\fP"

.PP
消除串中的转义字符 并返回一个新串 
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "int find (\fBString\fP sub)\fC [package]\fP"

.PP
在串中查找子串 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 子串 
.RE
.PP
\fB返回:\fP
.RS 4
找到的位置 找不到返回-1 
.RE
.PP

.SS "int find (\fBString\fP sub, int offset, int length)\fC [package]\fP"

.PP
在串中查找子串 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 子串 
.br
\fIoffset\fP 子串中的起始位置 
.br
\fIlength\fP 长度 
.RE
.PP
\fB返回:\fP
.RS 4
找到的位置 找不到返回-1 
.RE
.PP

.SS "\fBString\fP findExtension ()\fC [package]\fP"

.PP
当串为文件名时,寻找扩展名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP findFilename ()\fC [package]\fP"

.PP
当串为文件名时,寻找文件名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP findFilenameAndExtension ()\fC [package]\fP"

.PP
当串为文件名时,寻找文件名与扩展名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP findPathFilename ()\fC [package]\fP"

.PP
当串为文件名时,寻找路径和文件名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP findVolume ()\fC [package]\fP"

.PP
当串为文件名时,寻找卷名(限WINDOWS) 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP findVolumePath ()\fC [package]\fP"

.PP
当串为文件名时,寻找卷名与路径名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "static \fBString\fP format (\fBString\fP format, Object  [] args)\fC [static]\fP, \fC [package]\fP"

.PP
格式化对象 产生一个新串 
.PP
\fB参数:\fP
.RS 4
\fIformat\fP 格式 int %[n]d long %[n]d double %[\&.[n]]f char %(c|C) \fBString\fP s 
.RE
.PP
\fB异常:\fP
.RS 4
\fIIllegalArgumentException\fP 参数不正确 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "static \fBString\fP formatDate (\fBString\fP fmt, long millis)\fC [static]\fP, \fC [package]\fP"

.PP
格式化日期字符串 
.PP
\fB参数:\fP
.RS 4
\fIfmt\fP 格式 Y年 m月 d日 H时 M分 s 秒 可用格式如下 a: abbreviated weekday name A: full name of the weekday b: abbreviated month name B: full name of month c: locale's date and time reprensentation d: day of the month (01-31) H: hour of the day (00-23) I: hour of the day (01-12) j: day of the year (001-366) m: month of the year (01-12) M: minute (00-59) p: locale's version of AM or PM S: seconds (00-59) U: week number of the year (00-53) with Sunday as the first day of the week w: weekday (Sunday = 0 to Saturday = 6) W: week number of the year (00-53) with Monday as the first day of the week x: locale's date representation X: locale's time representation y: two-digit year representation (00-99) Y: four-digit year representation Z: time zone name  毫秒数 
.RE
.PP
\fB返回:\fP
.RS 4
格式化结果 
.RE
.PP

.SS "byte [] getBytes ()\fC [package]\fP"

.PP
获取串的byte数组内容 
.PP
\fB返回:\fP
.RS 4
数组 
.RE
.PP

.SS "int indexOf (\fBString\fP sub, int pos)\fC [package]\fP"

.PP
从串的前面查找另一个穿的位置 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的串 
.br
\fIpos\fP 开始查找的位置 
.RE
.PP
\fB返回:\fP
.RS 4
位置, 找不到返回-1 
.RE
.PP

.SS "int indexOf (char c, int pos)\fC [package]\fP"

.PP
从串的前面查找一个字符的位置 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的字符 
.br
\fIpos\fP 开始查找的位置 
.RE
.PP
\fB返回:\fP
.RS 4
位置, 找不到返回-1 
.RE
.PP

.SS "\fBString\fP insert (int pos, \fBString\fP sub)\fC [package]\fP"

.PP
在串的指定位置插入一个新串,并生成新串 
.PP
\fB参数:\fP
.RS 4
\fIpos\fP 插入的位置 
.br
\fIsub\fP 插入的子串 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP insert (int pos, char sub)\fC [package]\fP"

.PP
在串的指定位置插入一个字符,并生成新串 
.PP
\fB参数:\fP
.RS 4
\fIpos\fP 插入的位置 
.br
\fIsub\fP 插入的字符 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "bool isDigit ()\fC [package]\fP"

.PP
测试串是否数字 
.PP
\fB返回:\fP
.RS 4
是/否 
.RE
.PP

.SS "bool isDot ()\fC [package]\fP"

.PP
当串为文件名时,测试串是否为\&. 或者\&.\&. 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "int lastIndexOf (\fBString\fP sub, int pos)\fC [package]\fP"

.PP
从串的后面查找另一个穿的位置 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的串 
.br
\fIpos\fP 开始查找的位置 
.RE
.PP
\fB返回:\fP
.RS 4
位置, 找不到返回-1 
.RE
.PP

.SS "int lastIndexOf (char sub, int pos)\fC [package]\fP"

.PP
从串的后面查找一个字符的位置 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的字符 
.br
\fIpos\fP 开始查找的位置 
.RE
.PP
\fB返回:\fP
.RS 4
位置, 找不到返回-1 
.RE
.PP

.SS "int length ()\fC [package]\fP"

.PP
获取字串长度 
.PP
\fB返回:\fP
.RS 4
长度 
.RE
.PP

.SS "\fBString\fP lower ()\fC [package]\fP"

.PP
转换为小写 生成一个新串 
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP ltrim (bool bc)\fC [package]\fP"

.PP
去除串左端的空白字符 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fIbc\fP 指定是否将ASCII 0-0x20的控制字符全部删掉 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP operator + (byte two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (int two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (char two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (long two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (bool two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (double two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP operator + (\fBString\fP two)\fC [package]\fP"

.PP
串和对象相加 
.PP
\fB参数:\fP
.RS 4
\fItwo\fP 要相加的对象 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "bool parseBool ()\fC [package]\fP"

.PP
解析为bool对象 
.PP
\fB返回:\fP
.RS 4
解析结果, 失败返回false 
.RE
.PP

.SS "double parseDouble ()\fC [package]\fP"

.PP
解析为double对象 
.PP
\fB返回:\fP
.RS 4
解析结果, 失败返回0 
.RE
.PP

.SS "long parseHex ()\fC [package]\fP"

.PP
解析为十六进制long对象 
.PP
\fB返回:\fP
.RS 4
解析结果, 失败返回0 
.RE
.PP

.SS "int parseInt ()\fC [package]\fP"

.PP
解析为int对象 
.PP
\fB返回:\fP
.RS 4
解析结果, 失败返回0 
.RE
.PP

.SS "long parseLong ()\fC [package]\fP"

.PP
解析为long对象 
.PP
\fB返回:\fP
.RS 4
解析结果, 失败返回0 
.RE
.PP

.SS "\fBString\fP removeExtension ()\fC [package]\fP"

.PP
当串为文件名时,删除扩展名 并生成新串 
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP replace (int start, int end, \fBString\fP sub)\fC [package]\fP"

.PP
将串中指定的部分替换为另一个串 
.PP
\fB参数:\fP
.RS 4
\fIstart\fP 起始 
.br
\fIend\fP 结束 
.br
\fIsub\fP 另一个串 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP replace (\fBString\fP find, \fBString\fP rep)\fC [package]\fP"

.PP
在串中查找子串并替换为另一个串 
.PP
\fB参数:\fP
.RS 4
\fIfind\fP 要查找的串 
.br
\fIrep\fP 用以替换的串 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP replaceExtension (\fBString\fP newExtName)\fC [package]\fP"

.PP
当串为文件名时,替换扩展名 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fInewExtName\fP 新扩展名 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP replaceFilename (\fBString\fP newName)\fC [package]\fP"

.PP
当串为文件名时,替换文件名(保留扩展名) 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fInewExtName\fP 新文件名 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP replaceFilenameAndExtension (\fBString\fP newExtName)\fC [package]\fP"

.PP
当串为文件名时,替换文件名与扩展名 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fInewExtName\fP 新文件名和扩展名 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP rtrim (bool bc)\fC [package]\fP"

.PP
去除串右端的空白字符 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fIbc\fP 指定是否将ASCII 0-0x20的控制字符全部删掉 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP [] split (\fBString\fP dim)\fC [package]\fP"

.PP
在串中截取子串 
.PP
\fB参数:\fP
.RS 4
\fIdim\fP 分割符 
.RE
.PP
\fB返回:\fP
.RS 4
分割后的字符串数组 
.RE
.PP

.SS "\fBString\fP [] split (char dim)\fC [package]\fP"

.PP
在串中截取子串 
.PP
\fB参数:\fP
.RS 4
\fIdim\fP 分割符 
.RE
.PP
\fB返回:\fP
.RS 4
分割后的字符串数组 
.RE
.PP

.SS "bool startWith (\fBString\fP sub)\fC [package]\fP"

.PP
测试串是否由另一个字串起始 
.PP
\fB参数:\fP
.RS 4
\fIsub\fP 用以匹配的串 
.RE
.PP
\fB返回:\fP
.RS 4
是/否 
.RE
.PP

.SS "\fBString\fP substring (int start, int end)\fC [package]\fP"

.PP
在串中截取子串 
.PP
\fB参数:\fP
.RS 4
\fIstart\fP 起始位置 
.br
\fIend\fP 结束位置 
.RE
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP

.SS "\fBString\fP trim (bool bc)\fC [package]\fP"

.PP
去除串两端的空白字符 并生成新串 
.PP
\fB参数:\fP
.RS 4
\fIbc\fP 指定是否将ASCII 0-0x20的控制字符全部删掉 
.RE
.PP
\fB返回:\fP
.RS 4
结果 
.RE
.PP

.SS "\fBString\fP upper ()\fC [package]\fP"

.PP
转换为大写 生成一个新串 
.PP
\fB返回:\fP
.RS 4
新串 
.RE
.PP


.SH "作者"
.PP 
由 Doyxgen 通过分析 xlang 的 源代码自动生成\&.
