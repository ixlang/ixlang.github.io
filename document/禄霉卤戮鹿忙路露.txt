关键字(35个):
import  cdecl  stdcall  fastcall pascal operator for while do try catch if break continue
default  interface  class  package  static  const  throw  switch  case  else return  new
include using  require finally final synchronized_read  synchronized_write synchronized
@Declare override


注释
用于解释说明程序的文字。单行注释：//、多行注释：/*   */、文档注释：/**  */。


空白字符和空行
所有空白字符以及空行(不包括被""双引号包含)的部分, 在编译过程中都将被编译器忽略.


标识符
1）说明：标识符可以标识类名，变量名，接口名，方法名,  包名。
2）命名规则

（1）标识符是由，数字，字母，下划线和构成，其他符号不可以

（2）必须以字母、下划线开头，不能以数字开头

（3）关键字不能作为标识符

（4）标识符区分大小写

（5）标识符理论没有长度限制



变量

变量有四个基本属性：变量名，数据类型，存储单元和变量值。

（1）变量名：合法的标识符

（2）变量的数据类型：可以是基本类型, 数组和引用类型（必须包含类型）,数组类型必须用[]符号标明, []符号必须在类型之后, 变量名之前.

（3）存储单元：存储单元大小是由数据类型决定的，如：int为4个字节32位

（4）变量值：在存储单元中放的就是变量值（如果是基本类型放的就是具体值，如果是引用类型放的是内存地址，如果nilptr，表示不指向任何对象）

（5）变量的声明格式：类型 变量名；或者  类型 变量名 = 变量值, 可以同时声明多个变量,多个变量名之间必须用[,]分隔(不含方括号), 如 int a , b, c；

（6）变量数组声明时不能有数组长度, 
	例: 
	合法的声明:	int[ ] a;  
	不合法的声明:	int [3] a;   int  a[ ]; 	int a[3]  
	

常量

（1）说明：在程序执行的过程中其值不可以发生改变。

（2）分类：字面量常量、自定义常量。

（3）整数常量有2种表现形式：十进制、十六进制。


方法
（1）方法名：合法的标识符

（2）成员方法的修饰符 static , final,  非成员方法无效
	static 声明是静态方法, 使用前不需要实例化
	final 只对非static的成员方法有效, 表明该方法不可被派生类重写

（3）非void的方法必须有返回语句. void类型的方法不可有return语句

（4）形参必须有明确类型和名称

（5）变长参数用Object[] 表示, 编译器会自动将超出个数的参数装入Object数组传递

（6）抽象方法
	未定义方法主体的为抽象方法.
	抽象方法定义:
	返回值类型 函数名(形式参数类型1  参数名1,形式参数类型2  参数名2,形式参数类型3  参数名3......);

声明结构
修饰符 返回值类型 函数名(形式参数类型1  参数名1,形式参数类型2  参数名2,形式参数类型3  参数名3......)
{

方法主体语句;

return  返回值;
}



类
（1）类名：合法的标识符

（2）类的修饰符
	static 声明是静态方法, 使用前不需要实例化,  非成员类使用无效
	final 声明该方法不可被继承

（3）基类型
	基类型可以是任意不被final限定的类, 以及模板类

（4）成员类
	在其所有者类未实例化之前无法使用.
 	成员类可以使用所有者类的成员方法和对象(static类只能使用static对象),  所有者类指针为 ClassName.this.


（6）模板类.
	模板类可以有多个模板参数,模板参数必须是类, 或者预置的POD对象, 模板成员类可以使用所有者类的模板参数.
	模板类和普通类之间可以互相继承, 但模板类在没有明确参数之前不会被编译

（7）匿名类.
	匿名类必须是new创建, 并且必须指定基类并重写类主体的对象. 
	匿名类不可被继承
	匿名类可以使用在其所在作用域内的对象(闭包操作)
	
（8）类成员
	类
	变量
	常量
	方法
	native对象

（9）类成员方法
	所有的类成员方法均为虚函数任意派生类都可以重写, final和static修饰的方法除外
	非静态的类成员方法可以使用override强制重写,若找不到基类中可以重载的方法,将收到错误提示
	类成员方法允许存在纯虚函数, 但实例化之前必须被重写
	存在纯虚函数的类不可被实例化
	类成员方法可以为重载运算法的方法
	支持被重载的操作符:
		+              定义形式: 	类型 operator + (类型 参数名)
		- 	定义形式: 	类型 operator - (类型 参数名)
		/ 	定义形式 	类型 operator / (类型 参数名)
		* 	定义形式 	类型 operator * (类型 参数名)
		+= 	定义形式 	类型 operator += (类型 参数名)
		-= 	定义形式 	类型 operator -= (类型 参数名)
		*= 	定义形式 	类型 operator *= (类型 参数名)
		/= 	定义形式 	类型 operator /= (类型 参数名)
		== 	定义形式 	类型 operator == (类型 参数名)
		!= 	定义形式 	类型 operator != (类型 参数名)
		>> 	定义形式 	类型 operator >> (类型 参数名)
		<< 	定义形式 	类型 operator << (类型 参数名)
		< 	定义形式 	类型 operator < (类型 参数名)
		> 	定义形式 	类型 operator > (类型 参数名)
		<= 	定义形式 	类型 operator <= (类型 参数名)
		>= 	定义形式 	类型 operator >= (类型 参数名)
		<<= 	定义形式 	类型 operator <<= (类型 参数名)
		>>= 	定义形式 	类型 operator >>= (类型 参数名)
		&	定义形式 	类型 operator & (类型 参数名)
		 | 	定义形式 	类型 operator | (类型 参数名)
		^ 	定义形式 	类型 operator ^ (类型 参数名)
		~ 	定义形式 	类型 operator ~ (类型 参数名)
		&=	定义形式 	类型 operator &= (类型 参数名)
		 |= 	定义形式 	类型 operator |= (类型 参数名)
		^= 	定义形式 	类型 operator ^= (类型 参数名)
		++	定义形式 	前置自增 :  类型 operator ++ ()
				后置自增 :	 类型 operator ++ (int)
		--	定义形式 	前置自减 :  类型 operator -- ()
				后置自减 :	 类型 operator -- (int)
	操作符的优先级同数学运算的优先级


（10）类构造
	类如没有显式声明默认构造方法, 编译器将为其创建一个默认构造方法
	类如果存在有参构造方法且没有显式声明默认构造方法, 则该类将禁用默认构造方法
	派生类构造方法中显式调用基类构造方法使用super(args), 并且该代码放在派生类构造方法主体的最前面, 且仅能调用一次.
	派生类构造方法(无论是否有参)中若没有显式调用基类构造将隐式调用基类默认构造方法.
	基类若无默认构造函数,且该类为其他类的派生类时,在派生类构造的时候将跳过基类构造直接调用基类的基类默认构造方法.
	类构造顺序为先基类, 后派生类

（11）类的初始化
	类成员在类实例化之后 ,构造之前全部将被初始化, 
	指定了初始值的变量将被装载值
	没有指定初始值的变量初始化规则:
		1).数值型将被初始化为0
		2).bool 类型将被初始化为false
		3).String和其他类型将被初始化为nilptr

（12）类的析构
	定义形式: void finalize(){

		}

	类在销毁之前将调用finalize实施销毁前的清理工作
	类的销毁操作将在该类无任何引用的情况下不定时触发

（13）类的继承
	一个类可以只允许继承自另外的一个类或者接口, 不允许多重继承


（14）类的定义形式
	普通类:
	class  类名{  	类主体	};
	class  类名 : 基类型{  	类主体	};
	class  类名<模板参数类型1,模板参数类型2....> : 基类型{  	类主体	};



接口(interface):
	接口可以继承自另一个接口或者类

	接口的成员可以为:
		1.纯虚方法	
		2.抽象的重载运算符
		3.接口

	接口无法被实例化.

	声明形式:
	interface 标识符{
		抽象方法1;
		抽象方法2;
		抽象方法3;
	};


包:
	（1）包名：合法的标识符


	（1）包内容:
		1.包
		2.类
		3.接口

	（3）包的声明形式:
		package 标识符{
			包;
			类;
			接口;
		};
	（1）包的使用:
		在全局任意位置 使用using语法声明;
		或者使用 包.成员 形式语法.


native组件:
	native组件允许调用标准的C接口导出函数

	native方法:
		1）必须有返回类型
			返回类型只接受以下类型
			void
			byte
			char
			int
			long
			bool
			double
			String

		2）必须声明调用约定,支持以下调用约定
			stdcall
			cdecl
			fastcall
			pascal

		3）形参必须有明确类型, 可以无形参名称
			参数类型只接受以下类型
			void
			byte
			char
			int
			long
			bool
			double
			String
			ObjectPtr
		
		3）native方法至多接受32个参数

	声明形式:
	import "xxx.dll"{
		void stdcall MessageBoxA(int hWnd,String msg, String caption, int flag);
	};
	
	
using 语法
	在全局范围内使用using 声明要使用的包,可减少使用包内容时繁琐的输入.
	一条using语句可以声明多个包	
	例:
	using { a; b; };

new 语句
	new 用以创建对象和数组
	
	new的对象必须为类, 模板类,且类中没有抽象方法

	new数组时必须标明数组长度


include 语法
	用来引入其他的源文件并插入到include的位置
	一条include语句可以引入多个源文件
	每一次include都将有效引入文件内容
	例:
		include("a.xcsm", "b.xcsm");
	

require 语法
	用来引入其他的源文件并插入到include的位置
	一条include语句可以引入多个源文件
	被require引入的文件无法require第二次,在一次编译过程中,多处require同一个文件,只会第一次有效,其他的require请求将被忽略
	例:
		require("a.xcsm", "b.xcsm");


@Declare声明:
	@Declare 可以放在package 之前, class之前, interface之前用以标识该对象仅声明, 不编译
	被@Declare修饰的对象不会参与编译和代码生成,但会做基本语法检查.


结构化异常处理:
	1.一个结构化异常语句可以有零~多个catch语句 .
	2.一个结构化异常语句只可以包含0~1个finally语句
	3.finally结构中的return语句将收到警告.
	4.多层结构化异常语句嵌套时,最靠近当前层的异常处理语句会先得到catch机会
	5.catch语句有且只能有一个参数
	6.catch的参数类型必须继承自Exception类型
	7.引发的异常类型如果是自catch语句中的类型的派生类, 都会被该catch语句捕获

if语句
	1.if语句条件判断对象的类型必须为bool
	2.if语句可以使用{ }对多条语句进行条件化处理
	3.if语句如果不使用{ },将仅对下一条语句条件化处理
	
while语句
	1.while语句条件判断对象的类型必须为bool
	2.while语句可以使用{ }对多条语句进行条件化处理
	3.while语句如果不使用{ },将仅对下一条语句条件化处理

do while语句
	1.while语句条件判断对象的类型必须为bool
	2.do语句可以使用{ }对多条语句进行条件化处理
	3.do语句如果不使用{ },将仅对下一条语句条件化处理

switch case语句
	switch语句可以使用任何类型
	对于非pod类型的对象仅比较指针
	case语句中没有break的 ,不会产生break跳转

块同步语法:
	synchronized  块线程同步
		synchronized包裹的语句会与其他线程互斥

	synchronized_read
		synchronized_read包裹的语句会与该对象对应的synchronized_write语句互斥

	synchronized_write
		synchronized_read包裹的语句会与该对象对应的任何操作互斥


全局范围内可以使用的语法对象:
		1.定义方法
		2.using语句
		3.include语句
		4.reqiure语句
		5.native组件
		6.包
		7.定义变量
		8.定义类
		9.定义接口
		10.数学运算表达式
		11.调用方法
		12.new语句
		
	

同名对象选择优先级:
	1.栈
	2.成员
	3.堆和其他


运算符优先级:


-------------------------------------------------------------------------------------------------------------
优先级 		操作符		描述				结合方向
-------------------------------------------------------------------------------------------------------------
1		()		调节优先级的括号操作符		从左到右
		[]		数组下标访问操作符
		new{}/[]		创建对象/数组			从右到左
		.		访问成员的操作符			从左到右
		++		后置自增操作符
		--		后置自减操作符
-------------------------------------------------------------------------------------------------------------
2		!		逻辑取反操作符			从右到左
		~		按位取反
		++		前置自增操作符
		--		前置自减操作符
		-		一元取负操作符
-------------------------------------------------------------------------------------------------------------
3		*		乘法操作符			从左到右
		/		除法操作符
		%		取余数操作符
-------------------------------------------------------------------------------------------------------------
4		+		加法操作符			从左到右
		-		减法操作符
-------------------------------------------------------------------------------------------------------------
5		<<		按位左移操作符			从左到右
		>>		按位右移操作符
-------------------------------------------------------------------------------------------------------------
6		<		小于比较操作符			从左到右
		<=		小于或等于比较操作符
		>		大于比较操作符
		>=		大于或等于比较操作符

-------------------------------------------------------------------------------------------------------------
7		==		等于比较操作符			从左到右
		!=		不等于比较操作符
-------------------------------------------------------------------------------------------------------------
8		&		按位与操作符			从左到右
-------------------------------------------------------------------------------------------------------------
9		^		按位异或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
10		|		按位或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
11		&&		逻辑与操作符			从左到右
-------------------------------------------------------------------------------------------------------------
12		||		逻辑或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
13		? :		三元条件操作符			从右到左
-------------------------------------------------------------------------------------------------------------
14		=		赋值操作符			从右到左
		+=		复合赋值操作符(加法)
		-=		复合赋值操作符(减法)
		*=		复合赋值操作符(乘法)
		/=		复合赋值操作符(除法)
		%=		复合赋值操作符(取余)
		&=		复合赋值操作符(按位与)
		^=		复合赋值操作符(按位异或)
		|=		复合赋值操作符(按位或)
		<<=		复合赋值操作符(按位左移)
		>>=		复合赋值操作符(按位右移)
-------------------------------------------------------------------------------------------------------------
