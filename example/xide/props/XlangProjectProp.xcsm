
class XlangProjectProp : ProjectPropInterface{
    static const String _compile_path = ("bin/xcross.exe");
	static const String _compile_path_linux = ("bin/xcross");
    static const String warning = "警告:";
    static const String error = "错误:";
    static const String tips = "提示:";

	int XDEBUG_SERIAL = 0;
    
    Process process ;
    static class CompileInfo : ICompileInfo{
        String file;
        int line;
        int row;
        int type;
        String tip;
        CompileInfo(String s, int l,int r){
            
        }
        
        CompileInfo(String text, int t, String _tips){
            int pos = text.lastIndexOf("(");
            int rpos = text.lastIndexOf(")");
            if (pos != -1 && rpos != -1){
            
                file = text.substring(0, pos - 1);
                String linerow = text.substring(pos + 1, rpos - 1);
                
                String []lr = linerow.split(',');
                if (lr.length == 2){
                
                        int m = lr[0].indexOf(':');
                        
                        if (m != -1){
                            line = lr[0].substring(m + 1, lr[0].length() - 1).parseInt();
                        }
                        
                        m = lr[1].indexOf(':');
                        
                        if (m != -1){
                            row = lr[1].substring(m + 1, lr[1].length() - 1).parseInt();
                        }
                }
                
                if (_tips != nilptr){
					byte [] tipdata = _tips.getBytes();
                    try{
						tip = new String(tipdata, "CP936");
                    }catch(Exception e){
						tip = new String(tipdata);
                    }
                }
                type = t;
            }else{
                type = -1;
            }
        }
        
        int getType()override{
            return type;
        }
        String getFile()override{
            return file;
        }
        int getLine()override{
            return line;
        }
        int getRow()override{
            return row;
        }
        String getTips(){
			return tip;
        }
    };


	static String getCompilerPath(){
		String workDir = _system_.getWorkDirector();
		if (_system_.getPlatformId() == 0){
			return workDir.appendPath(_compile_path);
		}
		return workDir.appendPath(_compile_path_linux);
	}

    bool setValue(Project object, Configure configure,  String key, String value)override{
        if (key.equals("projname")){
            return true;
        }
        if (key.equals("projtype")){
            if (value.equals("xlang 可执行文件(-c)")){
                configure.setOption("command", "-c");
                return true;
            }
            if (value.equals("可执行文件(-ce)")){
                configure.setOption("command", "-ce");
                return true;
            }
            if (value.equals("xlang 静态链接库(-lix -c)")){
                configure.setOption("command", "-lix -c");
                return true;
            }
            return false;
        }
        if (key.equals("wtype")){
			if (value.equals("当前开发环境")){
				configure.setOption("wtype", "");
            }else{
				configure.setOption("wtype", value);
            }
			return true;
        }
        if (key.equals("projout")){
			if (value.indexOf("$(Output)") != -1){
				return false;
            }
            configure.setOption("outpath", value);
            return true;
        }
        if (key.equals("libspath")){
            configure.setLibsPath(value);
            return true;
        }
        if (key.equals("libs")){
            configure.setLibs(value);
            return true;
        }
        if (key.equals("incspath")){
            configure.setIncsPath(value);
            return true;
        }
        if (key.equals("outfile")){
        	if (value.indexOf("$(Output)") != -1){
				return false;
            }
            configure.setOption("outname", value);
            return true;
        }
        if (key.equals("cmd")){
            configure.setOption("cmd", value);
            return true;
        }
        if (key.equals("arglist")){
            configure.setOption("args", value);
            return true;
        }
        if (key.equals("workdir")){
            configure.setOption("workdir", value);
            return true;
        }
        if (key.equals("ignorew")){
            if (value.equals("启用(-w)")){
                configure.setOption("ignorewarning", "-w");
            }else{
                configure.setOption("ignorewarning", "");
            }
            
            return true;
        }
        if (key.equals("debuginfo")){
            if (value.equals("禁用(-nd)")){
                configure.setOption("debugdatabase", "-nd");
            }else{
                configure.setOption("debugdatabase", "");
            }
            return true;
        }
        if (key.equals("debugable")){
            if (value.equals("禁用(nilptr)")){
                configure.setOption("debugable", "");
            }else{
                configure.setOption("debugable", "-dbg");
            }
            return true;
        }
        return true;
    }
        
    String getValue(Project object, Configure configure,  String key)override{
        if (key.equals("projname")){
            return object.getName();
        }        

        if (key.equals("projtype")){
            String type = configure.getOption("command");
            if (type.equals("-ce")){
                return "1";
            }
            if (type.equals("-c")){
                return "0";
            }
            if (type.equals("-lix -c")){
                return "2";
            }
            return "未知";
        }
        if (key.equals("wtype")){
            String type = configure.getOption("wtype");
            if (type.equals("")){
                return "0";
            }
            if (type.equals("-arch:x86")){
                return "1";
            }
            if (type.equals("-arch:x86_64")){
                return "2";
            }
            if (type.equals("-arch:arm")){
                return "3";
            }
            if (type.equals("-arch:arm64")){
                return "4";
            }
            if (type.equals("-arch:mips")){
                return "5";
            }
            return "未知";
        }
        if (key.equals("libspath")){
            return configure.getLibsPath();
        }
        if (key.equals("libs")){
            return configure.getLibs();
        }
        if (key.equals("incspath")){
            return configure.getIncsPath();
        }
        if (key.equals("projout")){
            return configure.getOption("outpath");
        }
        if (key.equals("outfile")){
            return configure.getOption("outname");
        }
        if (key.equals("cmd")){
            return configure.getOption("cmd");
        }
        if (key.equals("arglist")){
            return configure.getOption("args");
        }
        if (key.equals("workdir")){
            return configure.getOption("workdir");
        }
        if (key.equals("ignorew")){
            String options = configure.getOption("ignorewarning");
            if (options != nilptr && options.equals("-w")){
                return "0";
            }else{
                return "1";
            }
        }
        if (key.equals("debuginfo")){
            String options = configure.getOption("debugdatabase");
            if (options != nilptr && options.equals("-nd")){
                return "1";
            }else{
                return "0";
            }
        }
        if (key.equals("debugable")){
            String options = configure.getOption("debugable");
            if (options != nilptr && options.equals("-dbg")){
                return "0";
            }else{
                return "1";
            }
        }       
        return "";
    }
    bool testOptions(String options, String opt){
        String[] opts = options.split(' ');
        for (int i = 0; i < opts.length; i++){
            /*_system_.consoleWrite(opts[i] + " matched " + opt + "\n");*/
            if (opts[i].equals(opt)){
                return true;
            }
        }
        return false;
    }
    
    void generateCommand(Configure configure, Vector<String> sourceArgs){
		String cmd = configure.getOption("command");
        String []cmds = cmd.split(' ');
        for (int i =0; i < cmds.length; i++){
			sourceArgs.add(cmds[i]);
        }
    }
    Vector<String> getSourceArgs(Project object, Configure configure, String workDir){
		Vector<String> sourceArgs = new Vector<String>();
        String compiler_path = getCompilerPath();

		if (_system_.getPlatformId() == 0){
			sourceArgs.add("\"" + compiler_path + "\"");
		}else{
			sourceArgs.add(compiler_path);
		}
		
		generateCommand(configure, sourceArgs);

        JsonArray sources = object.getSources();
		if (_system_.getPlatformId() == 0){ /* windows */
			for (int i = 0; i < sources.length(); i++){
				String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm")) ){
					String source = "\"" + workDir.appendPath(srcname) + "\" ";
					sourceArgs.add(source);
                }
			}
		}else{
			for (int i = 0; i < sources.length(); i++){
            	String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") )){
					sourceArgs.add(workDir.appendPath(srcname));
                }
			}
		}

        
        return sourceArgs;
    }
    
    String getArch(Configure configure){
		String [] archs = {"unknow", "x86", "x64", "arm", "arm64", "mips"};
        
		String arch = configure.getOption("wtype");
        if (arch.equals("")){
			int aid = _system_.getArchId();
            
            if (aid < 0 || aid > 5){
				aid = 0;
            }
            return archs[aid];
            
        }else{
			if (arch.equals("-arch:x86")){
				return archs[1];
            }else
            if (arch.equals("-arch:x86_64")){
				return archs[2];
            }else
            if (arch.equals("-arch:arm")){
				return archs[3];
            }else
            if (arch.equals("-arch:arm64")){
				return archs[4];
            }else
            if (arch.equals("-arch:mips")){
				return archs[5];
            }else{
				return archs[0];
            }
        }
    }
    
    String getArchArgs(Configure configure){
		String [] archs = {"", "-arch:x86", "-arch:x86_64", "-arch:arm", "-arch:arm64", "-arch:mips"};
        
		String arch = configure.getOption("wtype");
        if (arch.equals("")){
			int aid = _system_.getArchId();
            
            if (aid <= 0 || aid > 5){
				aid = 1;
            }
            return archs[aid];
            
        }else{
			return arch;
        }
    }
    
    String map_variable(Project object, Configure configure, String text){
		text = text.replace("$(Output)", configure.getOption("outpath").appendPath(configure.getOption("outname")));
        text = text.replace("$(Configure)", configure.getName());
        text = text.replace("$(Arch)", getArch(configure));
        return object.map_variable(text);
    }
    
    void generateJsonArrayArgs(String key, JsonArray incpath, Vector<String> args){
		if (incpath != nilptr){
			String incs = "";
            bool pushkey = false;
			for (int i = 0; i < incpath.length(); i++){
				String inc = incpath.getString(i);
				if (inc != nilptr && inc.length() > 0){
					if (pushkey == false){
						args.add(key);
                        pushkey = true;
					}
                    if (_system_.getPlatformId() == 0){
						args.add("\"" + inc + "\"");
                    }else{
						args.add(inc);
                    }
				}
			}
		}
    }
    
    void generatePath(Configure configure, Vector<String> args){
        if (configure.root == nilptr){
			return ;
        }
        
        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr){
			JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
			generateJsonArrayArgs("-incpath", incpath, args);
            generateJsonArrayArgs("-libpath", libpath, args);
        }

    }
    
    void generateLibs(Configure configure, Vector<String> args){
        if (configure.root == nilptr){
			return ;
        }
        
        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgs("-lib", libs, args);
    }
        
        
    void checkOptions(Vector<String> args, Configure configure, String []key){
		for (int i =0; i < key.length; i++){
			String option = configure.getOption(key[i]);
			
			if (option != nilptr && option.length() > 0){
				args.add(option);
			}else
            if (key[i].equals("wtype")){
				args.add(getArchArgs(configure));
            }
        }
    }
    
    String [] generateBuildArgs(Vector<String> __args, Project object, Configure configure){
        Vector<String> args = new Vector<String>();

		String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype"};
        
		checkOptions(args, configure, options);

        //路径变量
        generatePath(configure, args);
                
        //外部库
        generateLibs(configure, args);

		args.add("-o");

        String out_path = configure.getOption("outpath");
        out_path = map_variable(object, configure, out_path);
        mkdirs(out_path);
        
		if (_system_.getPlatformId() == 0){ /* windows */
			args.add("\"" + out_path.appendPath(configure.getOption("outname")) + "\"");
		}else{
			args.add(out_path.appendPath(configure.getOption("outname")));
		}
        
        String [] szArgs = new String[args.size() + __args.size()];

		int argpos = 0;

        for (int i = 0; i < __args.size(); i++){
            szArgs[argpos++] = QXNative.converToPlatformCharSet(__args.get(i));
        }

        for (int i = 0; i < args.size(); i++){
            szArgs[argpos++] = QXNative.converToPlatformCharSet(map_variable(object, configure, args.get(i)));
        }
        
        return szArgs;
    }
    

    
    bool mkdirs(String path){
        if (QXNative.existsSystemFile(path) == false){
            if (QXNative.mkdir(path) == false){
                mkdirs(path.findVolumePath());
                return QXNative.mkdir(path);
            }
        }
        return true;
    }
    
    int detectInfo(String line){
        if (line.endWith(warning)){
            return ICompileInfo.WARNING;
        }
        if (line.endWith(error)){
            return ICompileInfo.ERROR;
        }
        if (line.endWith(tips)){
            return ICompileInfo.TIPS;
        }
        return -1;
    }
    
    Vector<ICompileInfo> parseInfo(String info){
        Vector<ICompileInfo> infos = new Vector<ICompileInfo>();
        String [] list = info.split("\n");
        if (list != nilptr){
            for (int i = 0; i < list.length; i++){
                String message = list[i].trim(true);
                int t = detectInfo(message);
                if (t != -1){
					String tips_block = message;
                    i++;
					for (; i < list.length; i++){
                        if (list[i].startWith(" ")){
							tips_block = tips_block + "\n" + list[i];
                        }else{
							i--;
							break;                        
                        }
                    }
                    infos.add(new CompileInfo(message, t, tips_block));
                }
            }
        }
        return infos;
    }
    
    void build(IBuilder builder, Project object, Configure configure)override{
        String workdir = object.projpath.findVolumePath();

        Vector<String> _args = getSourceArgs(object, configure, workdir);

        String allInfo = "";
        if (configure == nilptr){
            Map.Iterator<String, Configure> iter = object.configures.iterator();
            
            while (iter.hasNext()){
                Configure conf = iter.getValue();
                String []args = generateBuildArgs(_args, object, conf);
                allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
                iter.next();
            }
        }else{
            String []args = generateBuildArgs(_args, object, configure);
            allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
        }
        builder.setCompileInfor(parseInfo(allInfo));
    }

	void stopRun()override{
		if (process != nilptr){
			process.exit(0);
		}
	}
    
    String getExecuteCmd(Project object, Configure configure){
        String out_path = configure.getOption("cmd");
        return map_variable(object, configure, out_path);
    }
    String getExecuteWd(Project object, Configure configure){
        String out_path = configure.getOption("workdir");
        return map_variable(object, configure, out_path);
    }
    Vector<String> getExecuteArgs(Project object, Configure configure){
		Vector<String> args_list = new Vector<String>();
        
        String out_path = configure.getOption("args");
        
        String args = map_variable(object, configure, out_path);
        
        byte []data = args.getBytes();
        
        int start = 0;
        bool inline = false;
        
        for (int i = 0; i < data.length; i++){
			
			if (data[i] == '"'){
				inline = !inline;
            }
            
            if (inline == false){
            
				if (data[i] == ' '){
                
					String arg = new String(data, start, i - start);
                    
                    start = i + 1;
                    
                    args_list.add(arg);
				}
            }
        }
        
        if (start < data.length){
			String arg = new String(data, start, data.length - start);
            args_list.add(arg);
        }
        
        return args_list;
    }
    
    int getDebugSerial(){
		if (XDEBUG_SERIAL == 0){
			XDEBUG_SERIAL = Process.getId() * 100;
        }else{
			XDEBUG_SERIAL++;
        }
		return XDEBUG_SERIAL;
    }
    
    void readForProcess(IBuilder builder, Process process){
		try{
			int rd = 0;
			byte [] buffer = new byte[1024];
			
			int pos = 0;
			while ((rd = process.read(buffer, pos, buffer.length - pos)) > 0){
				try{
					pos += rd;
					String oustr = "";
					if (_system_.getPlatformId() == 0){
						oustr = new String(buffer, 0, pos, "CP936");
					}else{
						oustr = new String(buffer, 0, pos);
					}
					pos = 0;
					builder.OutputText(oustr);
				}catch(Exception e){
					byte [] newbuf = new byte[buffer.length + 1024];
					_system_.arrayCopy(buffer, 0, newbuf, 0, pos);
					buffer = newbuf;
				}
			}
		}catch(Exception e){
		
		}    
    }
    
    bool checkDebugFlag(String path){
		long hf = QXNative.openSystemFile(path, "r");
        if (hf == 0){
			return false;
        }
        
        bool bret = false;
        
        _system_.seekFile(hf, Stream.SeekEnd, -4);
        
        byte[] flag = new byte[4];
        if (4 == _system_.readFile(hf, flag, 0, 4)){
			if (flag[0] == 'x' && flag[1] == 'd' && flag[2] == 'b'&& flag[3] == 'g'){
				bret = true;
            }
        }
        _system_.closeFile(hf);
        
        return bret;
    }
    
    void debugRun(IBuilder builder, Project proj, Configure conf)override{
		if (XWorkspace.isDebugging()){
			builder.OutputText("\调试器已在运行中,请等待当前调试工作结束.\n");
            return ;
        }
        int debugSerial = getDebugSerial();
        
        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/
        
        if (checkDebugFlag(exePath) == false){
			builder.OutputText("\n目标程序:" + exePath + "不支持调试,请在[项目]->[属性]->[编译选项]中开启调试后重新编译\n");
            XWorkspace.workspace.notSupportDebug();
            return ;
        }
        
        Vector<String> args = getExecuteArgs(proj, conf);
        args.add("-xdbg:" + debugSerial);
        
        String []args__ = nilptr;
        
        if (args.size() > 0){
			args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++){
				args__[i] = args.get(i);
            }
        }
        
        process = new Process(exePath, args__);
        process.setWorkDirectory(getExecuteWd(proj, conf));
        
        String statusoutput = "\n运行: " + exePath + " ";

		for (int i = 0; i < args.size(); i++){
			statusoutput = statusoutput + args.get(i) + " ";
		}
            
        builder.OutputText(statusoutput + "\n");
        
        try{
			if (XWorkspace.workspace.debugPrepare("127.0.0.1", debugSerial)){
				bool readforstdout = _system_.getPlatformId() != 0;
				if (process.create(true, readforstdout, false, false)){
					builder.OutputText("\n已创建进程 ID: " + process.id() + "\n");

					if (XWorkspace.workspace.debug() == false){
						builder.OutputText("\n调试器失败.\n");
                        process.exit(0);
                    }
                    if (readforstdout){
						readForProcess(builder, process);
                    }
					process.waitFor(-1);
                    //XWorkspace.workspace.debugClose();
					builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
				}else{
					
					builder.OutputText("\n运行失败.\n");
				}
            }else{
				builder.OutputText("\n调试器正忙.\n");
            }
        }catch(Exception e){
			String str = e.getMessage();
			
			builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
        }finally{
			XWorkspace.workspace.debugClose();
        }
    }
    
    void Run(IBuilder builder, Project proj, Configure conf)override{
        
        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/
        Vector<String> args = getExecuteArgs(proj, conf);
        
        String []args__ = nilptr;
        
        if (args.size() > 0){
			args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++){
				args__[i] = args.get(i);
            }
        }
        
        process = new Process(exePath, args__);
        process.setWorkDirectory(getExecuteWd(proj, conf));
        
        builder.OutputText("\n运行: " + exePath + "\n");
        
        try{
			bool readforstdout = _system_.getPlatformId() != 0;
            if (process.create(true, readforstdout, false, false)){
				if (readforstdout){
					readForProcess(builder, process);
				}
                process.waitFor(-1);
                builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
            }else{
                builder.OutputText("\n运行失败.\n");
            }
        }catch(Exception e){
			String str = e.getMessage();
			
			builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
        }
    }
    
    static bool copyFile(String source, String dest){
		try{
			FileInputStream fis = new FileInputStream(source);
			FileOutputStream fos = new FileOutputStream(dest);
			fos.write(fis.read());
			return true;
		}catch(Exception e){
		
		}
        return false;
    }
    
    
    bool createZTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		QXNative.mkdir(projectDir);
        
		String confFile = QXNative.getAppDirectory().appendPath("config").appendPath(uuid + ".utemp");
        
        String destProj = projectDir.appendPath(projectName + ".xprj");
        
        if (extartToDir(confFile, projectDir, projectName)){
			generateProjectFile(destProj, projectName);
        }
        
		loader.loadProject(destProj);
		return true;
    }
    
    
    
    bool generateProjectFile(String destFile, String projectName){
		try{
			FileInputStream fis = new FileInputStream(destFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			fis.close();
			
			FileOutputStream fos = new FileOutputStream(destFile);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
		}catch(Exception e){
			return false;
		}
        return true;
    }
    
    bool createTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		QXNative.mkdir(projectDir);
        
        
		String confFile = "./config/" + uuid + ".prop";
		String destProj = projectDir.appendPath(projectName + ".xprj");
		try{
			FileInputStream fis = new FileInputStream(confFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			
			
			FileOutputStream fos = new FileOutputStream(destProj);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
			String mainFile = projectDir.appendPath(projectName + ".xcs");
			fos = new FileOutputStream(mainFile);
            
            confFile = "./config/" + uuid + ".temp";
			fis = new FileInputStream(confFile);
			data = fis.read();
			content = new String(data);    
			fos.write(content.getBytes());
			fos.close();
		}catch(Exception e){
			return false;
		}
		loader.loadProject(destProj);
		return true;
    
    }
        
	bool createNormalProject(WizardLoader loader,String projectName, String projectDir, String uuid){
		QXNative.mkdir(projectDir);
		String confFile = "./config/" + uuid + ".prop";
		String destProj = projectDir.appendPath(projectName + ".xprj");
		try{
			FileInputStream fis = new FileInputStream(confFile);
			byte [] data = fis.read();
			String content = new String(data);
			content = content.replace("${ProjectName}", projectName);
			
			
			FileOutputStream fos = new FileOutputStream(destProj);
			byte [] odata = content.getBytes();
			fos.write(odata);
			fos.close();
			String mainFile = projectDir.appendPath(projectName + ".xcs");
			fos = new FileOutputStream(mainFile);
            String out_class = 	"//xlang " + 
								"\npackage System{" + 
								"\n	class out{" +
								"\n		static int println(String text){"	+
								"\n			return _system_.consoleWrite(text + \"\\n\");" +
                                "\n		}"	+
                                "\n		static int print(String text){"	+
								"\n			return _system_.consoleWrite(text);" +
                                "\n		}"	+
                                "\n	};" +
                                "\n	"	+
                                "\n	class Console{"	+
                                "\n		Console(){"	+
                                "\n			_system_.createConsole();" +
                                "\n		}" +
                                "\n	};" +
                                "\n};" + 
                                "\n\n" +
                                "\nusing { System; };"	+
                                "\n\n" +
                                "\nint main(String [] args){"	+
                                "\n\n	new Console();"	+
                                "\n\n	System.out.println(\"hello world\");" +
                                "\n\n	Thread.sleep(3000);"	+
                                "\n\n	return 0;"	+
                                "\n}\n";
                                
			fos.write(out_class.getBytes());
			fos.close();
		}catch(Exception e){
			return false;
		}
		loader.loadProject(destProj);
		return true;
	}
    
    bool extartToDir(String zfile, String dir, String projName){
		
        FileInputStream fis;
        
        try{
			fis = new FileInputStream(zfile);
        }catch(Exception e){
			return false;
        }
        
        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
		if (zs.open(fis)){
			int c = zs.getEntriesCount();
			for (int i =0; i < c; i ++){
				ZipEntry entry = zs.getEntry(i);
				if (bSuccess == false){
					break;
                }
                String entryName = entry.getName();
                entryName = entryName.replace("${ProjectName}", projName);
                
                String path = String.formatPath(dir.appendPath(entryName), false);
                
				if (entry.isDirectory() == false){
					ZipFile file = entry.getFile();
					
					byte []buf = new byte[1024];
					int rd = 0;
					if (file.open()){
						long filehandler = QXNative.openSystemFile(path, "w");
                        if (filehandler != 0){
							while ((rd = file.read(buf, 0, 1024)) != 0){
								_system_.writeFile(filehandler, buf, 0, rd);
							}
							_system_.closeFile(filehandler);
                        }else{
							bSuccess = false;
                        }
						file.close();
					}else{
						bSuccess = false;
                    }
				}else{
					QXNative.mkdir(path);
                }
			}
            zs.close();
		}else{
			bSuccess = false;
        }
        
        return bSuccess;
    }
    
	bool createNormalFileToProject(WizardLoader loader,String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String ext){
		QXNative.mkdir(projectDir);
		try{
			String extsion = projectName.findExtension();
			String filename ;
			if (extsion != nilptr){
				filename = projectName;
			}else{
				filename = projectName + ext;
			}
				
			String destProj = projectDir.appendPath(filename);
			
			FileOutputStream fos = new FileOutputStream(destProj);
			String date = String.formatDate("%c", _system_.currentTimeMillis()); 
			fos.write(("//xlang Source, Name:" + filename + " \n" + "//Date: " + date + " \n").getBytes());
			fos.close();
			loader.openTextFile(destProj);
			if (addToProject){
				return ownProject.addSource(destProj);
			}
			return true;
		}catch(Exception e){
			
		}
		return false;
	}
	bool create(WizardLoader loader, String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String userType)override{
    
		if (userType != nilptr && userType.equals("project")){
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = projectDir.appendPath(projectName);
			if (QXNative.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }
        
		if (uuid.equals("100911ae-27e8-4479-a56f-af015358f1a6")){
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = projectDir.appendPath(projectName);
			if (QXNative.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
			return createNormalProject(loader, projectName, priject_dir, uuid);
		}
        
		if (uuid.equals("76d637db-bbaa-4a4f-907b-84d3a8cc15a2") || 
			uuid.equals("e5787cae-9900-4c41-9eb5-08e61cfc0fb2")		|| 
			uuid.equals("651c2524-d9a5-40e9-b6cf-3d480bc75631") ||
            uuid.equals("0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e") ||
            uuid.equals("85384b44-719b-4aaa-8c8b-ad5ecec4201b") || 
            uuid.equals("5e5ab583-973f-41cd-98cb-ac5208557f8b") )
        {
			if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false){
				QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}
			String priject_dir = projectDir.appendPath(projectName);
			if (QXNative.existsSystemFile(priject_dir)){
				QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
				return false;
			}else{
				if (mkdirs(priject_dir) == false){
					QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
					return false;
				}
			}
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }
        
		if (uuid.equals("262b6f61-478a-4968-b800-1f22520ef0bf")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcs");
		}
		if (uuid.equals("8f95f230-7662-4543-9495-6f7cd083c2b9")){
			return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcsm");
		}
		return false;
	}
};