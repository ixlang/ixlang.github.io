
class XlangProjectProp : ProjectPropInterface {

    static const String _compile_path = ("bin/xlang.exe");
    static const String _compile_path_linux = ("bin/xlang");

    static const String warning = "警告:";
    static const String error = "错误:";
    static const String tips = "提示:";

    int XDEBUG_SERIAL = 0;

    Process process ;
    static class CompileInfo : ICompileInfo {
        String file;
        int line;
        int row;
        int type;
        String tip;
        CompileInfo(String s, int l,int r) {

        }

        CompileInfo(String text, int t, String _tips) {
            int pos = text.lastIndexOf("(");
            int rpos = text.lastIndexOf(")");
            if (pos != -1 && rpos != -1) {

                file = text.substring(0, pos);
                String linerow = text.substring(pos + 1, rpos);

                String []lr = linerow.split(',');
                if (lr.length == 2) {

                    int m = lr[0].indexOf(':');

                    if (m != -1) {
                        line = lr[0].substring(m + 1, lr[0].length()).parseInt();
                    }

                    m = lr[1].indexOf(':');

                    if (m != -1) {
                        row = lr[1].substring(m + 1, lr[1].length()).parseInt();
                    }
                }

                if (_tips != nilptr) {
                    byte [] tipdata = _tips.getBytes();
                    try {
                        tip = new String(tipdata, "CP936");
                    } catch(Exception e) {
                        tip = new String(tipdata);
                    }
                }
                type = t;
            } else {
                type = -1;
            }
        }

        int getType()override {
            return type;
        }
        String getFile()override {
            return file;
        }
        int getLine()override {
            return line;
        }
        int getRow()override {
            return row;
        }
        String getTips() {
            return tip;
        }
    };


    static String getCompilerPath() {
        String comppath = _system_.getAppDirectory();
        if (_system_.getPlatformId() == 0) {
            comppath = comppath.appendPath(_compile_path);
        } else {
            comppath = comppath.appendPath(_compile_path_linux);
        }
        return String.formatPath(comppath,false);
    }

    bool setValue(Project object, Configure configure,  String key, String value)override {
        if (key.equals("projname")) {
            return true;
        }
        if (key.equals("icofile")) {
            object.setOption(key, value);
            return true;
        }
        if (key.equals("versioninc")) {
            if (value.equals("启用")) {
                object.setOption("versioninc", "1");
            } else {
                object.setOption("versioninc", "0");
            }
            return true;
        }
        if (key.equals("uaclevel")) {
            configure.setOption(key, value);
            return true;
        }
        if (key.equals("projtype")) {
            if (value.equals("xlang 可执行文件(-c)")) {
                configure.setOption("command", "-c");
                return true;
            }
            if (value.equals("可执行文件(-ce)")) {
                configure.setOption("command", "-ce");
                return true;
            }
            if (value.equals("xlang 静态链接库(-lix -c)")) {
                configure.setOption("command", "-lix -c");
                return true;
            }
            if (value.equals("xlang 共享库(-slx -c)")) {
                configure.setOption("command", "-slx -c");
                return true;
            }
            if (value.equals("xlang 链接库(-xl -c)")) {
                configure.setOption("command", "-xl -c");
                return true;
            }
            return false;
        }
        if (key.equals("wtype")) {
            if (value.equals("缺省")) {
                configure.setOption("wtype", "");
            } else {
                configure.setOption("wtype", value);
            }
            return true;
        }
        if (key.equals("ostype")) {
            if (value.equals("缺省")) {
                configure.setOption("ostype", "");
            } else {
                configure.setOption("ostype", value);
            }
            return true;
        }

        /*if (key.equals("deploypath")){
        	if (value.indexOf("$(Deploy)") != -1){
        		return false;
            }
            configure.setOption("deploypath", value);
            return true;
        }*/
        if (key.equals("projout")) {
            if (value.indexOf("$(Output)") != -1) {
                return false;
            }
            configure.setOption("outpath", value);
            return true;
        }
        if (key.equals("libspath")) {
            configure.setLibsPath(value);
            return true;
        }
        if (key.equals("libs")) {
            configure.setLibs(value);
            return true;
        }
        if (key.equals("links")) {
            configure.setLinks(value);
            return true;
        }
        if (key.equals("incspath")) {
            configure.setIncsPath(value);
            return true;
        }
        if (key.equals("outfile")) {
            if (value.indexOf("$(Output)") != -1) {
                return false;
            }
            configure.setOption("outname", value);
            return true;
        }
        if (key.equals("cmd")) {
            configure.setOption("cmd", value);
            return true;
        }
        if (key.equals("acmd")) {
            configure.setOption("acmd", value);
            return true;
        }
        if (key.equals("arglist")) {
            configure.setOption("args", value);
            return true;
        }
        if (key.equals("workdir")) {
            configure.setOption("workdir", value);
            return true;
        }
        if (key.equals("makebuild")) {
            configure.setOption("makebuild", value);
            return true;
        }
        if (key.equals("makeclean")) {
            configure.setOption("makeclean", value);
            return true;
        }
        if (key.equals("prebuild")) {
            configure.setOption("prebuild", value);
            return true;
        }
        if (key.equals("afterbuild")) {
            configure.setOption("afterbuild", value);
            return true;
        }
        if (key.equals("preclean")) {
            configure.setOption("preclean", value);
            return true;
        }
        if (key.equals("afterclean")) {
            configure.setOption("afterclean", value);
            return true;
        }
        if (key.equals("ignorew")) {
            if (value.equals("启用(-w)")) {
                configure.setOption("ignorewarning", "-w");
            } else {
                configure.setOption("ignorewarning", "");
            }

            return true;
        }
        if (key.equals("ignorewl")) {
            configure.setOption(key, value);
            return true;
        }
        if (key.equals("debuginfo")) {
            if (value.equals("禁用(-nd)")) {
                configure.setOption("debugdatabase", "-nd");
            } else {
                configure.setOption("debugdatabase", "");
            }
            return true;
        }
        if (key.equals("debugable")) {
            if (value.equals("禁用(nilptr)")) {
                configure.setOption("debugable", "");
            } else {
                configure.setOption("debugable", "-dbg");
            }
            return true;
        }
        if (key.equals("compdest")) {
            if (value.equals("禁用(nilptr)")) {
                configure.setOption("compdest", "");
            } else {
                configure.setOption("compdest", "-z");
            }
            return true;
        }
        return true;
    }

    String getValue(Project object, Configure configure,  String key)override {
        if (key.equals("projname")) {
            return object.getName();
        }
        if (key.equals("icofile")) {
            return object.getOption(key);
        }
        if (key.equals("versioninc")) {
            return object.getOption(key);
        }
        if (key.equals("uaclevel")) {
            String type =  configure.getOption(key);
            if (type.equals("管理员(-uac-admin)")) {
                return "1";
            }
            if (type.equals("最高级别(-uac-highest)")) {
                return "2";
            }
            return "0";
        }
        if (key.equals("projtype")) {
            String type = configure.getOption("command");
            if (type.equals("-ce")) {
                return "1";
            }
            if (type.equals("-c")) {
                return "0";
            }
            if (type.equals("-lix -c")) {
                return "2";
            }
            if (type.equals("-slx -c")) {
                return "3";
            }
            if (type.equals("-xl -c")) {
                return "4";
            }
            return "未知";
        }
        if (key.equals("wtype")) {
            String type = configure.getOption("wtype");
            if (type.equals("")) {
                return "0";
            }
            if (type.equals("-arch:x86")) {
                return "1";
            }
            if (type.equals("-arch:x86_64")) {
                return "2";
            }
            if (type.equals("-arch:arm")) {
                return "3";
            }
            if (type.equals("-arch:arm64")) {
                return "4";
            }
            if (type.equals("-arch:mips")) {
                return "5";
            }
            return type;
        }
        if (key.equals("ostype")) {
            String type = configure.getOption("ostype");
            if (type.equals("")) {
                return "0";
            }
            if (type.equals("-xcross-windows")) {
                return "1";
            }
            if (type.equals("-xcross-linux")) {
                return "2";
            }
            if (type.equals("-xcross-darwin")) {
                return "3";
            }
            return type;
        }
        if (key.equals("libspath")) {
            return configure.getLibsPath();
        }
        if (key.equals("libs")) {
            return configure.getLibs();
        }
        if (key.equals("links")) {
            return configure.getLinks();
        }
        if (key.equals("incspath")) {
            return configure.getIncsPath();
        }
        if (key.equals("projout")) {
            return configure.getOption("outpath");
        }
        /*if (key.equals("deploypath")){
            return configure.getOption("deploypath");
        }*/
        if (key.equals("outfile")) {
            return configure.getOption("outname");
        }
        if (key.equals("cmd")) {
            return configure.getOption("cmd");
        }
        if (key.equals("acmd")) {
            return configure.getOption("acmd");
        }
        if (key.equals("arglist")) {
            return configure.getOption("args");
        }
        if (key.equals("workdir")) {
            return configure.getOption("workdir");
        }
        if (key.equals("makebuild")) {
            return configure.getOption(key);
        }
        if (key.equals("makeclean")) {
            return configure.getOption(key);
        }
        if (key.equals("prebuild")) {
            return configure.getOption(key);
        }
        if (key.equals("afterbuild")) {
            return configure.getOption(key);
        }
        if (key.equals("preclean")) {
            return configure.getOption(key);
        }
        if (key.equals("afterclean")) {
            return configure.getOption(key);
        }
        if (key.equals("ignorewl")) {
            return configure.getOption(key);
        }
        if (key.equals("ignorew")) {
            String options = configure.getOption("ignorewarning");
            if (options != nilptr && options.equals("-w")) {
                return "0";
            } else {
                return "1";
            }
        }
        if (key.equals("debuginfo")) {
            String options = configure.getOption("debugdatabase");
            if (options != nilptr && options.equals("-nd")) {
                return "1";
            } else {
                return "0";
            }
        }
        if (key.equals("compdest")) {
            String options = configure.getOption("compdest");
            if (options != nilptr && options.equals("-z")) {
                return "0";
            } else {
                return "1";
            }
        }

        if (key.equals("debugable")) {
            String options = configure.getOption("debugable");
            if (options != nilptr && options.equals("-dbg")) {
                return "0";
            } else {
                return "1";
            }
        }

        return "";
    }
    bool testOptions(String options, String opt) {
        String[] opts = options.split(' ');
        for (int i = 0; i < opts.length; i++) {
            /*_system_.consoleWrite(opts[i] + " matched " + opt + "\n");*/
            if (opts[i].equals(opt)) {
                return true;
            }
        }
        return false;
    }

    void generateCommand(Configure configure, Vector<String> sourceArgs) {
        String cmd = configure.getOption("command");
        String []cmds = cmd.split(' ');
        for (int i =0; i < cmds.length; i++) {
            sourceArgs.add(cmds[i]);
        }
    }

    void makefile(IBuilder builder, Project object, Configure configure, String projectDir) {
        String [] margs = {"make"};

        String args = configure.getOption("makebuild");
        args = map_variable(object, configure, args);
        if (args != nilptr && args.length() > 0) {
            Vector<String> arglist = processArgs(args);
            if (arglist.size() > 0) {
                String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++) {
                    argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
            }
        }

        Process _mprocess = new Process("/usr/bin/make", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "/usr/bin/make " + args;

        builder.OutputText(statusoutput + "\n");

        try {
            if (_mprocess.create(false, true, false, false)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\nmakefile失败.\n");
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + str + "\n");
        }
    }

    void makefile_clean(IBuilder builder, Project object, Configure configure, String projectDir) {
        String [] margs = {"make", "clean"};

        String args = configure.getOption("makeclean");
        args = map_variable(object, configure, args);
        if (args != nilptr && args.length() > 0) {
            Vector<String> arglist = processArgs(args);
            if (arglist.size() > 0) {
                String []argmake = new String[arglist.size() + 1];
                argmake[0] = "make";
                for (int i = 0; i < arglist.size(); i++) {
                    argmake[1 + i] = arglist.get(i);
                }
                margs = argmake;
            }
        }

        Process _mprocess = new Process("/usr/bin/make", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "/usr/bin/make " + args;

        builder.OutputText(statusoutput + "\n");

        try {
            if (_mprocess.create(false, true, false, false)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\nmakefile失败.\n");
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + str + "\n");
        }
    }

    static class BuildParams {
        bool forgs;
        String output_source;
    };

    void IncrementVersionSection(String [] section, int id) {

        int verval = section[id].parseInt() + 1;

        if (verval > 65535 && id > 0) {
            IncrementVersionSection(section, id - 1);
            verval = 0;
        }
        section[id] = "" + verval;
    }

    void versionIncrement(IBuilder builder, String file) {
        try {
            FileInputStream fis = new FileInputStream(file);
            byte [ ] data = fis.read();
            fis.close();

            String str = new String(data);

            JsonObject root = new JsonObject(str);

            if (root != nilptr) {
                String filever = root.getString("FileVersion");
                if (filever == nilptr) {
                    filever = root.getString("ProductVersion");
                }
                if (filever != nilptr) {
                    String []versec = filever.split('.');

                    IncrementVersionSection(versec, versec.length - 1);

                    filever = "";
                    for (int i = 0; i < versec.length; i ++) {
                        if (i != 0) {
                            filever =  filever + "." + versec[i];
                        } else {
                            filever = filever + versec[i];
                        }
                    }

                    root.remove("FileVersion");
                    root.put("FileVersion", filever);

                    root.remove("ProductVersion");
                    root.put("ProductVersion", filever);


                    XWorkspace.workspace.qfsw.removePath(file);

                    FileOutputStream fos = new FileOutputStream(file);
                    fos.write(root.toString(true).getBytes());
                    fos.close();

                    XWorkspace.workspace.qfsw.addPath(file);

                    builder.OutputText("修订版本为:" + filever + "\n");
                }
            }
        } catch(Exception e) {
            builder.OutputText("修订版本时发生异常:" + e.getMessage() + "\n");
        }
    }

    Vector<String> getSourceArgs(IBuilder builder, Project object, Configure configure, String workDir, BuildParams param) {
        Vector<String> sourceArgs = new Vector<String>();
        String compiler_path = getCompilerPath();

        if (_system_.getPlatformId() == 0) {
            sourceArgs.add("\"" + compiler_path + "\"");
        } else {
            sourceArgs.add(compiler_path);
        }

        if (param == nilptr) {
            generateCommand(configure, sourceArgs);
        } else {
            sourceArgs.add("-gs");
        }

        bool fixver = object.getOption("versioninc").equals("1");

        JsonArray sources = object.getSources();
        if (_system_.getPlatformId() == 0) { /* windows */
            for (int i = 0; i < sources.length(); i++) {
                String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                //String fname = srcname.findFilenameAndExtension();

                String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version") || ext.equalsIgnoreCase(".xdef")) ) {
                    if (fixver) {
                        if (ext.equalsIgnoreCase(".version")) {
                            versionIncrement(builder, fullsourcePath);
                        }
                    }
                    String source = "\"" + fullsourcePath + "\" ";
                    sourceArgs.add(source);
                }
            }
        } else {
            for (int i = 0; i < sources.length(); i++) {
                String srcname = sources.getString(i);
                String ext = srcname.findExtension();
                String fname = srcname.findFilenameAndExtension();

                String fullsourcePath = String.formatPath(workDir.appendPath(srcname), false);

                if (fname.equalsIgnoreCase("makefile")) {
                    makefile(builder, object, configure, workDir);
                }
                if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) ) {
                    if (fixver) {
                        if (ext.equalsIgnoreCase(".version")) {
                            versionIncrement(builder, fullsourcePath);
                        }
                    }
                    sourceArgs.add(fullsourcePath);
                }
            }
        }


        return sourceArgs;
    }

    static String getArch(Configure configure) {
        String [] archs = {"unknow", "x86", "x64", "arm", "arm64", "mips"};

        String arch = configure.getOption("wtype");
        if (arch.equals("")) {
            int aid = _system_.getArchId();

            if (aid < 0 || aid > 5) {
                aid = 0;
            }
            return archs[aid];

        } else {
            if (arch.equals("-arch:x86")) {
                return archs[1];
            } else if (arch.equals("-arch:x86_64")) {
                return archs[2];
            } else if (arch.equals("-arch:arm")) {
                return archs[3];
            } else if (arch.equals("-arch:arm64")) {
                return archs[4];
            } else if (arch.equals("-arch:mips")) {
                return archs[5];
            } else {
                if (arch.length() > 6) {
                    return arch.substring(6,arch.length());
                }
                return arch;
            }
        }
    }

    String getArchArgs(Configure configure) {
        /*String [] archs = {"", "-arch:x86", "-arch:x86_64", "-arch:arm", "-arch:arm64", "-arch:mips"};

        String arch = configure.getOption("wtype");*/
        /*if (arch.equals("")){
        	int aid = _system_.getArchId();

            if (aid <= 0 || aid > 5){
        		aid = 1;
            }
            return archs[aid];
        }*/

        return configure.getOption("wtype");
    }

    String getXcrossName(Configure configure) {
        String [] archs = {"", "-xcross-windows", "-xcross-linux", "-xcross-darwin"};

        String arch = configure.getOption("ostype");
        if (arch.equals("") == false) {

            int aid = _system_.getArchId();

            if (aid <= 0 || aid > 3) {
                aid = 1;
            }
            return archs[aid + 1];

        } else {
            return arch;
        }
    }

    static String map_variable(Project object, Configure configure, String text) {
        text = text.replace("$(Output)", configure.getOption("outpath").appendPath(configure.getOption("outname")));
        text = text.replace("$(Configure)", configure.getName());
        text = text.replace("$(Arch)", getArch(configure));

        String ptype = configure.getOption("command");
        String ostype = configure.getOption("ostype");

        String ext = "";

        if (ptype.equals("-ce")) {
            if ((ostype.length() == 0 && _system_.getPlatformId() == 0) || ostype.equalsIgnoreCase("-xcross-windows")) {
                ext = ".exe";
            }
        } else if (ptype.equals("-lix -c")) {
            ext = ".lix";
        } else if (ptype.equals("-slx -c")) {
            ext = ".slx";
        } else if (ptype.equals("-xl -c")) {
            ext = ".xl";
        } else if (ptype.equals("-c")) {
            ext = ".exc";
        }


        text = text.replace("$(Ext)", ext);

        return object.map_variable(text);
    }

    void generateJsonArrayArgs(String key, JsonArray incpath, Vector<String> args) {
        if (incpath != nilptr) {
            //String incs = "";
            bool pushkey = false;
            for (int i = 0; i < incpath.length(); i++) {
                String inc = incpath.getString(i);
                if (inc != nilptr && inc.length() > 0) {
                    if (pushkey == false) {
                        args.add(key);
                        pushkey = true;
                    }
                    if (_system_.getPlatformId() == 0) {
                        args.add("\"" + inc + "\"");
                    } else {
                        args.add(inc);
                    }
                }
            }
        }
    }

    void generateJsonArrayArgsMake(JsonArray incpath, Vector<String> args) {
        if (incpath != nilptr) {
            //String incs = "";
            bool pushkey = false;
            for (int i = 0; i < incpath.length(); i++) {
                String inc = incpath.getString(i);
                if (inc != nilptr && inc.length() > 0) {
                    if (inc.indexOf(' ') != -1) {
                        args.add("\"" + inc + "\"");
                    } else {
                        args.add(inc);
                    }
                }
            }
        }
    }

    void generateWarning(Configure configure, Vector<String> args) {
        String values = configure.getOption("ignorewl");
        if (values.length() != 0) {
            args.add("-wl");
            String [] vals = values.split(';');
            for (int i = 0; i < vals.length; i++) {
                args.add(vals[i]);
            }
        }
    }

    void generatePathForMake(Configure configure, Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr) {
            JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
            generateJsonArrayArgsMake(incpath, args);
            generateJsonArrayArgsMake(libpath, args);
        }
    }

    void generateLibsForMake(Configure configure, Vector<String> args, Vector<String> linkarg) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgsMake(libs, args);

        JsonArray links = (JsonArray)configure.root.get("links");
        generateJsonArrayArgsMake(links, linkarg);
    }

    void generatePath(Configure configure, Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonObject paths = (JsonObject)configure.root.get("path");
        if (paths != nilptr) {
            JsonArray incpath = (JsonArray)paths.get("incpath");
            JsonArray libpath = (JsonArray)paths.get("libpath");
            generateJsonArrayArgs("-incpath", incpath, args);
            generateJsonArrayArgs("-libpath", libpath, args);
        }
    }

    void generateLibs(Configure configure, Vector<String> args) {
        if (configure.root == nilptr) {
            return ;
        }

        JsonArray libs = (JsonArray)configure.root.get("libs");
        generateJsonArrayArgs("-lib", libs, args);

        JsonArray links = (JsonArray)configure.root.get("links");
        generateJsonArrayArgs("-link", links, args);
    }


    void checkOptions(Vector<String> args, Map<String,String> argmap, Configure configure, String []key) {
        for (int i =0; i < key.length; i++) {
            String option = configure.getOption(key[i]);

            if (option != nilptr && option.length() > 0) {
                if (args != nilptr) {
                    args.add(option);
                }
                if (argmap != nilptr) {
                    argmap.put(key[i], option);
                }

            } else if (key[i].equals("wtype")) {
                String wtype = getArchArgs(configure);
                if (wtype.length() > 0) {
                    if (args != nilptr) {
                        args.add(wtype);
                    }
                    if (argmap != nilptr) {
                        argmap.put(key[i], wtype);
                    }
                }
            } else if (key[i].equals("ostype")) {
                String ostype = getXcrossName(configure);
                if (ostype.length() > 0) {
                    if (args != nilptr) {
                        args.add(ostype);
                    }
                    if (argmap != nilptr) {
                        argmap.put(key[i], ostype);
                    }
                }
            }
        }
    }


    String getMapValue(Map<String,String> args, String key) {
        Map.Iterator<String,String> iter = args.find(key);
        if (iter != nilptr) {
            return iter.getValue();
        }
        return "";
    }

    String getVectorPath(Vector<String> libs, String key) {
        String output = "";
        for (int i =0; i < libs.size(); i++) {
            output = output + " " + libs.get(i);
        }
        if (output.length() > 0) {
            return key + output;
        }

        return output.replace("\\", "/");
    }

    String generateMake(Project object, Configure configure) {

        String workdir = object.projpath.findVolumePath();

        String file = _system_.getAppDirectory();
        file = file.appendPath("config").appendPath(object.getLanguage() + ".mk");

        String template;

        try {
            FileInputStream fis = new FileInputStream(file);
            byte [] data = fis.read();
            template = new String(data);
            fis.close();
        } catch(Exception e) {
            return nilptr;
        }

        if (template == nilptr) {
            return nilptr;
        }


        Vector<String> libs = new Vector<String>();
        Vector<String> links = new Vector<String>();
        Vector<String> paths = new Vector<String>();

        Map<String,String> args = new Map<String,String>();

        String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype", "ostype", "compdest"};

        checkOptions(nilptr, args, configure, options);

        //路径变量
        generatePathForMake(configure, paths);

        //外部库
        generateLibsForMake(configure, libs, links);

        args.put("acmd",map_variable(object, configure, configure.getOption("acmd")));

        String uac = configure.getOption("uaclevel");
        if (uac.length() > 0) {
            if (uac.equals("管理员(-uac-admin)")) {
                args.put("uac", "-uac-admin");
            } else if (uac.equals("最高级别(-uac-highest)")) {
                args.put("uac", "-uac-highest");
            }
        }

        String icofile = object.getOption("icofile");

        if (icofile.length() > 0) {
            icofile = map_variable(object, configure, icofile).replace("\\", "/");
            if (icofile.lastIndexOf(' ') != -1) { /* windows */
                args.put("ico", "\"" + icofile + "\"");
            } else {
                args.put("ico", icofile);
            }
        }

        args.put("output",String.formatPath(map_variable(object, configure, configure.getOption("outpath").appendPath(configure.getOption("outname"))), false)
                 .toRelativePath(workdir,true)
                 .replace("\\", "/"));

        JsonArray sources = object.getSources();

        String sourcesText = "";

        String warning_dis = configure.getOption("ignorewl");
        warning_dis = warning_dis.trim(true).replace(";"," ");

        String command = configure.getOption("command");

        for (int i = 0; i < sources.length(); i++) {
            String srcname = sources.getString(i);
            String ext = srcname.findExtension();
            String fname = srcname.findFilenameAndExtension();

            String fullsourcePath = String.formatPath(workdir.appendPath(srcname), false);

            fullsourcePath = fullsourcePath.toRelativePath(workdir,true).replace("\\", "/");

            if (ext != nilptr && (ext.equalsIgnoreCase(".xcs") || ext.equalsIgnoreCase(".xcsm") || ext.equalsIgnoreCase(".version")) ) {
                if (fullsourcePath.indexOf(' ') != -1) {
                    fullsourcePath = "\"" + fullsourcePath + "\"";
                }
                if (sourcesText.length() != 0) {
                    sourcesText = sourcesText + " \\\n\t" + fullsourcePath;
                } else {
                    sourcesText = fullsourcePath;
                }
            }
        }

        String xflags = getMapValue(args, "ignorewarning") + " " +
                        getMapValue(args, "debugdatabase") +  " " +
                        getMapValue(args, "debugable") +  " " +
                        getMapValue(args, "compdest") +  " " +
                        getMapValue(args, "uac") +  " " +
                        getMapValue(args, "acmd");

        String output = getMapValue(args, "output");

        String icocmd = getMapValue(args, "ico");

        if (warning_dis.length() > 0) {
            xflags = xflags + " -wl " + warning_dis;
        }

        if (icocmd.length() > 0) {
            xflags = xflags + " -ico " + icocmd;
        }

        String xcross = getMapValue(args, "wtype") +  " " +
                        getMapValue(args, "ostype");

        String pathtext = getVectorPath(paths, "-libpath");

        String statictext = getVectorPath(libs, "-lib");

        String lxtext = getVectorPath(links, "-lx");

        return template.replace("${XFLAGS}", xflags)
               .replace("${PLATFORM_ARCH}", xcross)
               .replace("${OUTPUT}", output)
               .replace("${LIBPATH}", pathtext)
               .replace("${LX}", lxtext)
               .replace("${LIBS}", statictext)
               .replace("${SOURCES}", sourcesText)
               .replace("${CMD}", command);
    }

    String [] generateBuildArgs(Vector<String> __args, Project object, Configure configure, BuildParams param) {
        Vector<String> args = new Vector<String>();

        String []options = {"ignorewarning", "debugdatabase", "debugable", "wtype", "ostype", "compdest"};

        checkOptions(args, nilptr, configure, options);

        //路径变量
        generateWarning(configure, args);

        //路径变量
        generatePath(configure, args);

        //外部库
        generateLibs(configure, args);

        String acmd = map_variable(object, configure, configure.getOption("acmd"));

        if (acmd.length() > 0) {
            Vector<String> amcds = processArgs(acmd);
            if (amcds != nilptr) {
                for (int i =0; i < amcds.size(); i++) {
                    args.add(amcds.get(i));
                }
            }
        }

        String uac = configure.getOption("uaclevel");
        if (uac.length() > 0) {
            if (uac.equals("管理员(-uac-admin)")) {
                args.add("-uac-admin");
            } else if (uac.equals("最高级别(-uac-highest)")) {
                args.add("-uac-highest");
            }
        }

        String icofile = object.getOption("icofile");

        if (icofile.length() > 0) {
            args.add("-ico");
            icofile = map_variable(object, configure, icofile);
            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + icofile + "\"");
            } else {
                args.add(icofile);
            }
        }

        args.add("-o");

        String out_path = configure.getOption("outpath");

        if (param != nilptr) {
            out_path = param.output_source;
            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + out_path + "\"");
            } else {
                args.add(out_path);
            }
        } else {

            out_path = String.formatPath(map_variable(object, configure, out_path), false);
            mkdirs(out_path);

            if (_system_.getPlatformId() == 0) { /* windows */
                args.add("\"" + out_path.appendPath(configure.getOption("outname")) + "\"");
            } else {
                args.add(out_path.appendPath(configure.getOption("outname")));
            }
        }
        String [] szArgs = new String[args.size() + __args.size()];

        int argpos = 0;

        for (int i = 0; i < __args.size(); i++) {
            szArgs[argpos++] = XPlatform.converToPlatformCharSet(__args.get(i));
        }

        for (int i = 0; i < args.size(); i++) {
            szArgs[argpos++] = XPlatform.converToPlatformCharSet(map_variable(object, configure, args.get(i)));
        }

        return szArgs;
    }



    static bool mkdirs(String path) {
        if (XPlatform.existsSystemFile(path) == false) {
            if (XPlatform.mkdir(path) == false) {
                mkdirs(path.findVolumePath());
                return XPlatform.mkdir(path);
            }
        }
        return true;
    }

    int detectInfo(String line) {
        if (line.endWith(warning)) {
            return ICompileInfo.WARNING;
        }
        if (line.endWith(error)) {
            return ICompileInfo.ERROR;
        }
        if (line.endWith(tips)) {
            return ICompileInfo.TIPS;
        }
        return -1;
    }

    Vector<ICompileInfo> parseInfo(String info) {
        Vector<ICompileInfo> infos = new Vector<ICompileInfo>();
        String [] list = info.split("\n");
        if (list != nilptr) {
            for (int i = 0; i < list.length; i++) {
                String message = list[i].trim(true);
                int t = detectInfo(message);
                if (t != -1) {
                    String tips_block = message;
                    i++;
                    for (; i < list.length; i++) {
                        if (list[i].startWith(" ")) {
                            tips_block = tips_block + "\n" + list[i];
                        } else {
                            i--;
                            break;
                        }
                    }
                    infos.add(new CompileInfo(message, t, tips_block));
                }
            }
        }
        return infos;
    }

    String formatArgs(String param) {
        if (_system_.getPlatformId() == 0) {
            if (param.indexOf(" ") != -1) {
                return "\"" + param + "\"";
            }
        }
        return param;
    }

    void cleanup(IBuilder builder, Project object, Configure configure)override {
        batchbuild(builder, object, configure, "preclean");

        String workdir = object.projpath.findVolumePath();

        JsonArray sources = object.getSources();

        if (_system_.getPlatformId() != 0) { /* linux unix */
            for (int i = 0; i < sources.length(); i++) {
                String srcname = sources.getString(i);

                String fname = srcname.findFilenameAndExtension();

                if (fname.equalsIgnoreCase("makefile")) {
                    makefile_clean(builder, object, configure, workdir);
                }
            }
        }

        String target = getTarget(object, configure);

        builder.OutputText(target + "... \n");

        if (XPlatform.existsSystemFile(target)) {
            if (false == XPlatform.deleteFile(target)) {
                builder.OutputText("文件正在使用中,清理失败\n");
            }
        }

        batchbuild(builder, object, configure, "afterclean");

        builder.OutputText("[" + String.formatDate("%c", _system_.currentTimeMillis()) + "] 清理完成.\n");
    }


    class XKernel32 : Library {

        static bool loaded = false;

        static bool load() {
            if (loaded == false) {
                try {
                    loadLibrary("kernel32.dll");
                    loaded = true;
                } catch(Exception e) {

                }
            }
            return loaded;
        }

        static String getWindowsDir() {
            if (load()) {
                byte [] dir = new byte[320];
                int pathlen = GetWindowsDirectoryA(dir, 320);
                return new String(dir, 0, pathlen);
            }
            return nilptr;
        }

        import{
            int stdcall GetWindowsDirectoryA(
                ObjectPtr lpBuffer,
                int  uSize
            );
        };
    };


    void runbat(IBuilder builder, String batfile, String projectDir) {
        String [] margs = {"cmd", "/c", formatArgs(batfile)};

        String execute = XKernel32.getWindowsDir();
        if (execute == nilptr) {
            return;
        }

        execute = String.formatPath( execute.appendPath("system32\\cmd.exe"), false);
        Process _mprocess = new Process(execute, margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "bat scripts " + batfile;

        builder.OutputText(statusoutput + "\n");

        try {
            if (_mprocess.create(false, true, false, false)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\n build scripts失败.\n");
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n");
        }
    }

    void runsh(IBuilder builder, String shfile, String projectDir) {
        String [] margs = {"bash", "-c", shfile};
        Process _mprocess = new Process("/bin/bash", margs);
        _mprocess.setWorkDirectory(projectDir);

        String statusoutput = "bash scripts " + shfile;

        builder.OutputText(statusoutput + "\n");

        try {
            if (_mprocess.create(false, true, false, false)) {
                Utils.readForProcess(builder, _mprocess);
                _mprocess.waitFor(-1);
            } else {
                builder.OutputText("\n build scripts失败.\n");
            }

        } catch(Exception e) {
            String str = e.getMessage();
            builder.OutputText("\n错误:" + XPlatform.converPlatformCharSetTo(str) + "\n");
        }
    }

    void batchbuild(IBuilder builder, Project object, Configure configure, String key) {
        String workdir = object.projpath.findVolumePath();

        String txt = configure.getOption(key);

        if (txt == nilptr || txt.length() == 0) {
            return;
        }

        String batfile = map_variable(object, configure, txt);

        int osid = _system_.getPlatformId();

        if (osid == 0) {
            runbat(builder, batfile, workdir);
        } else {
            runsh(builder, batfile, workdir);
        }
    }


    bool build(IBuilder builder, Project object, Configure configure, Object param)override {

        String target = getTarget(object, configure);

        if (XPlatform.existsSystemFile(target)) {
            if (false == XPlatform.deleteFile(target)) {
                builder.OutputText("无法删除文件:" + target + " ,文件正在使用中\n");
                return false;
            }
        }

        batchbuild(builder, object, configure, "prebuild");

        String workdir = object.projpath.findVolumePath();

        Vector<String> _args = getSourceArgs(builder, object, configure, workdir, (BuildParams)param);

        String allInfo = "";
        if (configure == nilptr) {
            Map.Iterator<String, Configure> iter = object.configures.iterator();

            while (iter.hasNext()) {
                Configure conf = iter.getValue();
                String []args = generateBuildArgs(_args, object, conf, nilptr);
                allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
                iter.next();
            }
        } else {
            String []args = generateBuildArgs(_args, object, configure, (BuildParams)param);
            allInfo = allInfo + builder.build(getCompilerPath(), args, workdir);
        }

        batchbuild(builder, object, configure, "afterbuild");

        builder.setCompileInfor(parseInfo(allInfo));
        return true;
    }

    void stopRun()override {
        if (process != nilptr) {
            process.exit(0); 
            Thread.sleep(80);
        } 
    }

    String getTarget(Project object, Configure configure) {
        String out_path = map_variable(object, configure, "$(Output)");
        return String.formatPath(out_path, false);
    }

    String getExecuteCmd(Project object, Configure configure) {
        String out_path = configure.getOption("cmd");
        out_path = map_variable(object, configure, out_path);
        return String.formatPath(out_path, false);
    }
    String getExecuteWd(Project object, Configure configure) {
        String out_path = configure.getOption("workdir");
        out_path = map_variable(object, configure, out_path);
        return String.formatPath(out_path, false);
    }

    Vector<String> processArgs(String args) {
        Vector<String> args_list = new Vector<String>();

        byte []data = args.getBytes();

        int start = 0;
        bool inline = false;

        for (int i = 0; i < data.length; i++) {

            if (data[i] == '"') {
                inline = !inline;
            }

            if (inline == false) {

                if (data[i] == ' ') {

                    String arg = new String(data, start, i - start);

                    start = i + 1;

                    args_list.add(arg);
                }
            }
        }

        if (start < data.length) {
            String arg = new String(data, start, data.length - start);
            args_list.add(arg);
        }

        return args_list;
    }

    Vector<String> getExecuteArgs(Project object, Configure configure) {

        String out_path = configure.getOption("args");
        Vector<String> argve = processArgs(out_path);

        Vector<String> finalargs = new Vector<String>();

        for (int i =0; i < argve.size(); i++) {
            finalargs.add(formatArgs(String.formatPath(map_variable(object, configure, argve.get(i)), false)));
        }

        return finalargs;
    }

    int getDebugSerial() {
        if (XDEBUG_SERIAL == 0) {
            XDEBUG_SERIAL = Process.getId() * 100;
        } else {
            XDEBUG_SERIAL++;
        }
        return XDEBUG_SERIAL;
    }


    bool checkDebugFlag(String path) {
        long hf = XPlatform.openSystemFile(path, "r");
        if (hf == 0) {
            return false;
        }

        bool bret = false;

        _system_.seekFile(hf, Stream.SeekEnd, -4);

        byte[] flag = new byte[4];
        if (4 == _system_.readFile(hf, flag, 0, 4)) {
            if (flag[0] == 'x' && flag[1] == 'd' && flag[2] == 'b'&& flag[3] == 'g') {
                bret = true;
            }
        }
        _system_.closeFile(hf);

        return bret;
    }

    void debugRun(IBuilder builder, Project proj, Configure conf)override {
        if (XWorkspace.isDebugging()) {
            builder.OutputText("\调试器已在运行中,请等待当前调试工作结束.\n");
            return ;
        }
        int debugSerial = getDebugSerial();

        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/

        if (_system_.getPlatformId() != 2) {
            if (checkDebugFlag(exePath) == false) {
                if (XPlatform.existsSystemFile(exePath) == false) {
                    builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n");
                    XWorkspace.workspace.executeNotExists();
                } else {
                    builder.OutputText("\n目标程序:" + exePath + "不支持调试,请在[项目]->[属性]->[编译选项]中开启调试后重新编译\n");
                    XWorkspace.workspace.notSupportDebug();
                }

                return ;
            }
        }
        Vector<String> args = getExecuteArgs(proj, conf);
        args.add("-xdbg:" + debugSerial);

        String []args__ = nilptr;

        if (args.size() > 0) {
            args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++) {
                args__[i] = XPlatform.converToPlatformCharSet(args.get(i));
            }
        }

        process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
        process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));

        String statusoutput = "\n运行: " + exePath + " ";

        for (int i = 0; i < args.size(); i++) {
            statusoutput = statusoutput + args.get(i) + " ";
        }

        builder.OutputText(statusoutput + "\n");

        try {
            if (XWorkspace.workspace.debugPrepare("127.0.0.1", debugSerial)) {
                bool readforstdout = Setting.isRelocalStdout();
                if (process.create(true, readforstdout, false, false)) {
                    builder.OutputText("\n已创建进程 ID: " + process.id() + "\n");

                    if (XWorkspace.workspace.debug() == false) {
                        builder.OutputText("\n调试器失败.\n");
                        process.exit(0);
                    }
                    if (readforstdout) {
                        Utils.readForProcess(builder, process);
                    }
                    process.waitFor(-1);
                    //XWorkspace.workspace.debugClose();
                    builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
                } else {

                    builder.OutputText("\n运行失败.\n");
                }
            } else {
                builder.OutputText("\n调试器正忙.\n");
            }
        } catch(Exception e) {

            if (e.getErrorCode() == 0x000002E4) {
                XWorkspace.workspace.runOnUi(new Runnable() {
                    void run()override {
                        if (QXMessageBox.Question("注意", "被调试程序需要提升权限, 是否重新以提升的权限运行?", QXMessageBox.Ok | QXMessageBox.Cancel, QXMessageBox.Ok) == QXMessageBox.Ok) {
                            XWorkspace.runAsAdministrator();
                        }
                    }
                });
            }

            String str = e.getMessage();

            if (_system_.getPlatformId() == 0) {
                builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
            } else {
                builder.OutputText("\n错误:" + str + "\n");
            }
        }
        finally{
            XWorkspace.workspace.debugClose();
        }
    }

    void Run(IBuilder builder, Project proj, Configure conf)override {

        String exePath = getExecuteCmd(proj, conf);/*getBuildFile(proj, conf);*/

        if (XPlatform.existsSystemFile(exePath) == false) {
            builder.OutputText("\n没有找到目标程序:" + exePath + ",请先编译生成.\n");
            return ;
        }

        Vector<String> args = getExecuteArgs(proj, conf);

        String []args__ = nilptr;

        if (args.size() > 0) {
            args__ = new String[args.size()];
            for (int i =0; i < args__.length; i++) {
                args__[i] = XPlatform.converToPlatformCharSet(args.get(i));
            }
        }

        process = new Process(XPlatform.converToPlatformCharSet(exePath), args__);
        process.setWorkDirectory(XPlatform.converToPlatformCharSet(getExecuteWd(proj, conf)));

        builder.OutputText("\n运行: " + exePath + "\n");

        try {
            bool readforstdout = Setting.isRelocalStdout();
            if (process.create(true, readforstdout, false, false)) {
                if (readforstdout) {
                    Utils.readForProcess(builder, process);
                }
                process.waitFor(-1);
                builder.OutputText("\n退出代码: " + process.getExitCode() + "\n");
            } else {
                builder.OutputText("\n运行失败.\n");
            }
        } catch(Exception e) {
            String str = e.getMessage();
            if (_system_.getPlatformId() == 0) {
                builder.OutputText("\n错误:" + new String(str.getBytes(), "GB18030//IGNORE") + "\n");
            } else {
                builder.OutputText("\n错误:" + str + "\n");
            }
        }
    }

    static bool copyFile(String source, String dest) {
        if (XPlatform.existsSystemFile(source)) {
            try {
                FileOutputStream fos = new FileOutputStream(dest);
                fos.write(new FileInputStream(source).read());
                fos.close();
                return true;
            } catch(Exception e) {

            }
        }
        return false;
    }


    bool createZTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid) {
        XPlatform.mkdir(projectDir);

        String confFile = XPlatform.getAppDirectory().appendPath("config").appendPath(uuid + ".utemp");

        String destProj = projectDir.appendPath(projectName + ".xprj");

        if (extartToDir(confFile, projectDir, projectName)) {
            generateProjectFile(destProj, projectName);
            generateLibs(projectDir, uuid);
        }

        loader.loadProject(destProj);
        return true;
    }

    bool createExampleProject(WizardLoader loader,String projectName, String projectDir, String localFile) {
        XPlatform.mkdir(projectDir);

        String projectFile = extartExampleToDir(localFile,projectDir,".xprj");

        if (projectFile != nilptr) {
            loader.loadProject(projectFile);
            return true;
        }
        return false;
    }

    void copyQtLibs(String projectDir) {
        String source = XPlatform.getAppDirectory().appendPath("lib").appendPath("QXLibrary.lix");
        String dest = projectDir.appendPath("libs").appendPath("QXLibrary.lix");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.dll");
        dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.dll");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dll");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dll");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86").appendPath("QXLibrary.so");
        dest = projectDir.appendPath("x86").appendPath("debug").appendPath("QXLibrary.so");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.so");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.so");
        copyFile(source, dest);

        source = XPlatform.getAppDirectory().appendPath("lib").appendPath("x86_64").appendPath("QXLibrary.dylib");
        dest = projectDir.appendPath("x64").appendPath("debug").appendPath("QXLibrary.dylib");
        copyFile(source, dest);
    }

    bool generateLibs(String projectDir, String uuid) {
        String [] qtprojs = {"0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e", "5e5ab583-973f-41cd-98cb-ac5208557f8b"};

        for (int i =0; i < qtprojs.length; i++) {
            if (qtprojs[i].equals(uuid)) {
                copyQtLibs(projectDir);
                break;
            }
        }

        return true;
    }

    bool generateProjectFile(String destFile, String projectName) {
        try {
            FileInputStream fis = new FileInputStream(destFile);
            byte [] data = fis.read();
            String content = new String(data);
            content = content.replace("${ProjectName}", projectName);
            fis.close();

            FileOutputStream fos = new FileOutputStream(destFile);
            byte [] odata = content.getBytes();
            fos.write(odata);
            fos.close();
        } catch(Exception e) {
            return false;
        }
        return true;
    }

    bool createTemplateProject(WizardLoader loader,String projectName, String projectDir, String uuid) {
        XPlatform.mkdir(projectDir);


        String confFile = "./config/" + uuid + ".prop";
        String destProj = projectDir.appendPath(projectName + ".xprj");
        try {
            FileInputStream fis = new FileInputStream(confFile);
            byte [] data = fis.read();
            String content = new String(data);
            content = content.replace("${ProjectName}", projectName);


            FileOutputStream fos = new FileOutputStream(destProj);
            byte [] odata = content.getBytes();
            fos.write(odata);
            fos.close();
            String mainFile = projectDir.appendPath(projectName + ".xcs");
            fos = new FileOutputStream(mainFile);

            confFile = "./config/" + uuid + ".temp";
            fis = new FileInputStream(confFile);
            data = fis.read();
            content = new String(data);
            fos.write(content.getBytes());
            fos.close();
        } catch(Exception e) {
            return false;
        }
        loader.loadProject(destProj);
        return true;

    }

    bool createNormalProject(WizardLoader loader,String projectName, String projectDir, String uuid) {
        XPlatform.mkdir(projectDir);
        String confFile = "./config/" + uuid + ".prop";
        String destProj = String.formatPath(projectDir.appendPath(projectName + ".xprj"), false);
        try {
            FileInputStream fis = new FileInputStream(confFile);
            byte [] data = fis.read();
            String content = new String(data);
            content = content.replace("${ProjectName}", projectName);


            FileOutputStream fos = new FileOutputStream(destProj);
            byte [] odata = content.getBytes();
            fos.write(odata);
            fos.close();
            String mainFile = projectDir.appendPath(projectName + ".xcs");
            fos = new FileOutputStream(mainFile);
            String out_class = 	"//xlang " +
                                "\npackage System{" +
                                "\n	class out{" +
                                "\n		static int println(String text){"	+
                                "\n			return _system_.consoleWrite(text + \"\\n\");" +
                                "\n		}"	+
                                "\n		static int print(String text){"	+
                                "\n			return _system_.consoleWrite(text);" +
                                "\n		}"	+
                                "\n	};" +
                                "\n	"	+
                                "\n	class Console{"	+
                                "\n		Console(){"	+
                                "\n			_system_.createConsole();" +
                                "\n		}" +
                                "\n	};" +
                                "\n};" +
                                "\n\n" +
                                "\nusing { System; };"	+
                                "\n\n" +
                                "\nint main(String [] args){"	+
                                "\n\n	new Console();"	+
                                "\n\n	System.out.println(\"hello world\");" +
                                "\n\n	Thread.sleep(3000);"	+
                                "\n\n	return 0;"	+
                                "\n}\n";

            fos.write(out_class.getBytes());
            fos.close();
        } catch(Exception e) {
            return false;
        }
        loader.loadProject(destProj);
        return true;
    }

    bool extartToDir(String zfile, String dir, String projName) {

        FileInputStream fis;

        try {
            fis = new FileInputStream(zfile);
        } catch(Exception e) {
            return false;
        }

        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
        if (zs.open(fis)) {
            int c = zs.getEntriesCount();
            for (int i =0; i < c; i ++) {
                ZipEntry entry = zs.getEntry(i);
                if (bSuccess == false) {
                    break;
                }
                String entryName = entry.getName();
                entryName = entryName.replace("${ProjectName}", projName);

                String path = String.formatPath(dir.appendPath(entryName), false);

                if (entry.isDirectory() == false) {
                    ZipFile file = entry.getFile();

                    byte []buf = new byte[1024];
                    int rd = 0;
                    if (file.open()) {
                        long filehandler = XPlatform.openSystemFile(path, "w");
                        if (filehandler != 0) {
                            while ((rd = file.read(buf, 0, 1024)) != 0) {
                                _system_.writeFile(filehandler, buf, 0, rd);
                            }
                            _system_.closeFile(filehandler);
                        } else {
                            bSuccess = false;
                        }
                        file.close();
                    } else {
                        bSuccess = false;
                    }
                } else {
                    XPlatform.mkdir(path);
                }
            }
            zs.close();
        } else {
            bSuccess = false;
        }

        return bSuccess;
    }

    String  extartExampleToDir(String zfile, String dir, String extsion) {

        String projectName = nilptr;

        FileInputStream fis;

        try {
            fis = new FileInputStream(zfile);
        } catch(Exception e) {
            return nilptr;
        }

        bool bSuccess = true;
        ZipArchive zs = new ZipArchive();
        if (zs.open(fis)) {
            int c = zs.getEntriesCount();
            for (int i =0; i < c; i ++) {
                ZipEntry entry = zs.getEntry(i);
                if (bSuccess == false) {
                    break;
                }
                String entryName = entry.getName();
                String extision = entryName.findExtension();
                if (extision != nilptr ) {
                    if (extision.equalsIgnoreCase(extsion)) {
                        projectName = String.formatPath(dir.appendPath(entryName), false);
                    }
                }
                //entryName = entryName.replace("${ProjectName}", projName);

                String path = String.formatPath(dir.appendPath(entryName), false);

                if (entry.isDirectory() == false) {
                    ZipFile file = entry.getFile();

                    byte []buf = new byte[1024];
                    int rd = 0;
                    if (file.open()) {
                        long filehandler = XPlatform.openSystemFile(path, "w");
                        if (filehandler != 0) {
                            while ((rd = file.read(buf, 0, 1024)) != 0) {
                                _system_.writeFile(filehandler, buf, 0, rd);
                            }
                            _system_.closeFile(filehandler);
                        } else {
                            bSuccess = false;
                        }
                        file.close();
                    } else {
                        bSuccess = false;
                    }
                } else {
                    XPlatform.mkdir(path);
                }
            }
            zs.close();
        } else {
            projectName = nilptr;
        }

        return projectName;
    }

    byte [] getContentForNewFile(String filename,Project project, String uuid) {

        String projectName = "XApp";
        if (project != nilptr) {
            projectName = project.getName();
        }
        if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")) {
            //ui
            String default_content = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                                     "<ui version=\"4.0\">" +
                                     " <class>MainWindow</class>" +
                                     " <widget class=\"QMainWindow\" name=\"MainWindow\">" +
                                     "  <property name=\"geometry\">" +
                                     "   <rect>" +
                                     "    <x>0</x>" +
                                     "    <y>0</y>" +
                                     "    <width>719</width>" +
                                     "    <height>545</height>" +
                                     "   </rect>" +
                                     "  </property>" +
                                     "  <property name=\"windowTitle\">" +
                                     "   <string>MainWindow</string>" +
                                     "  </property>" +
                                     "  <widget class=\"QWidget\" name=\"centralwidget\"/>" +
                                     "  <widget class=\"QMenuBar\" name=\"menubar\">" +
                                     "   <property name=\"geometry\">" +
                                     "    <rect>" +
                                     "     <x>0</x>" +
                                     "     <y>0</y>" +
                                     "     <width>719</width>" +
                                     "     <height>23</height>" +
                                     "    </rect>" +
                                     "   </property>" +
                                     "  </widget>" +
                                     "  <widget class=\"QStatusBar\" name=\"statusbar\"/>" +
                                     " </widget>" +
                                     " <resources/>" +
                                     " <connections/>" +
                                     "</ui>";
            return default_content.getBytes();
        } else if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")) {
            // version
            JsonObject json = new JsonObject();
            json.put("FileVersion","1.0.0.0");
            json.put("ProductVersion", "1.0.0.0");

            json.put("ProductName", projectName);
            json.put("InternalName", projectName + ".exe");

            json.put("CompanyName", "XStudio");
            json.put("LegalCopyright", "Copyright (C) 2018 X-Studio");

            json.put("FileDescription", projectName);
            return json.toString(true).getBytes();
        } else if (uuid.equals("ddd530a0-1573-44b7-9f6c-06642e3151ad")) {
            // version
            JsonObject json = new JsonObject();
            json.put("library",  project.getName() + ".slx");

            JsonArray export_def = new JsonArray();

            export_def.put("MyClass.subClass");
            export_def.put("MyClass1");

            JsonArray hidden_def = new JsonArray();

            hidden_def.put("MyClass2.subClass");
            hidden_def.put("MyClass3");

            json.put("exports",export_def);
            json.put("hidden",hidden_def);

            return json.toString(true).getBytes();
        }

        String date = String.formatDate("%c", _system_.currentTimeMillis());
        return ("//xlang Source, Name:" + filename + " \n" + "//Date: " + date + " \n").getBytes();

    }
    bool createNormalFileToProject(WizardLoader loader,String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String ext) {
        XPlatform.mkdir(projectDir);
        try {
            String extsion = projectName.findExtension();
            String filename ;
            if (extsion != nilptr) {
                filename = projectName;
            } else {
                filename = projectName + ext;
            }

            String destProj = String.formatPath(projectDir.appendPath(filename), false);

            if (XPlatform.existsSystemFile(destProj)) {
                if (QXMessageBox.Question("注意", destProj + "<a style=\"color:#ffff0000\">继续建立新文件将改写原有文件?</a>", QXMessageBox.Ok | QXMessageBox.No, QXMessageBox.Ok) == QXMessageBox.No) {
                    return false;
                }
            }

            FileOutputStream fos = new FileOutputStream(destProj);

            fos.write(getContentForNewFile(filename, ownProject, uuid));
            fos.close();
            loader.openTextFile(destProj);
            if (addToProject) {
                return ownProject.addSource(destProj);
            }
            return true;
        } catch(Exception e) {

        }
        return false;
    }
    bool create(WizardLoader loader, String projectName, String projectDir, String uuid, Project ownProject, bool addToProject, String userType)override {

        if (userType != nilptr && userType.equals("project")) {
            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }

        if (uuid.equals("100911ae-27e8-4479-a56f-af015358f1a6")) {
            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createNormalProject(loader, projectName, priject_dir, uuid);
        }

        if (uuid.equals("76d637db-bbaa-4a4f-907b-84d3a8cc15a2") ||
            uuid.equals("e5787cae-9900-4c41-9eb5-08e61cfc0fb2")	||
            uuid.equals("651c2524-d9a5-40e9-b6cf-3d480bc75631") ||
            uuid.equals("0ef0fe5d-5ab9-4d62-ab6a-ee78f059ad1e") ||
            uuid.equals("85384b44-719b-4aaa-8c8b-ad5ecec4201b") ||
            uuid.equals("5e5ab583-973f-41cd-98cb-ac5208557f8b") ||
            uuid.equals("48791fab-9225-4baf-a3e4-fe10f2d48a55") ||
            uuid.equals("917e553d-0008-49db-83ca-d601b92c9ff3")) {

            if (Pattern.test(projectName, "^[A-Za-z0-9_]+$", Pattern.NOTEMPTY, true) == false) {
                QXMessageBox.Critical("错误", "项目名称不合法", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            }
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            if (XPlatform.existsSystemFile(priject_dir)) {
                QXMessageBox.Critical("错误", "该位置已存在同名项目, 请重新选择路径或者改变项目名", QXMessageBox.Ok, QXMessageBox.Ok);
                return false;
            } else {
                if (mkdirs(priject_dir) == false) {
                    QXMessageBox.Critical("错误", "无法在此位置建立新目录, 请重新选择路径", QXMessageBox.Ok, QXMessageBox.Ok);
                    return false;
                }
            }
            return createZTemplateProject(loader, projectName, priject_dir, uuid);
        }

        if (uuid.equals("262b6f61-478a-4968-b800-1f22520ef0bf")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcs");
        }
        if (uuid.equals("8f95f230-7662-4543-9495-6f7cd083c2b9")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xcsm");
        }
        if (uuid.equals("f55e671c-d2fe-4414-b060-fac629ccda6d")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".ui");
        }
        if (uuid.equals("f48d4411-6b02-4f8b-a961-23a2e079c55c")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".version");
        }
        if (uuid.equals("ddd530a0-1573-44b7-9f6c-06642e3151ad")) {
            return createNormalFileToProject(loader, projectName, projectDir, uuid, ownProject, addToProject, ".xdef");
        }

        if (userType.equals("example")) {
            String priject_dir = String.formatPath(projectDir.appendPath(projectName), false);
            return createExampleProject(loader, projectName, priject_dir, uuid);
        }
        return false;
    }
};