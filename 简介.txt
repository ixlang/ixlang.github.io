这是个编译器 + 虚拟机.

此项目采用C++编写(VS2013), 2018年4月初立项, 因为是业余开发, 中间经常断断续续的, 所以有空的时候才能做.

本来是想写个简单易用的一个脚本语言,谁知道越写越像java, 简直是又像java 又像C++

编译器并没有生成机器码, 而是生成了在虚拟机运行的字节码.

名字没去想 随便起了个.

搞完编译器和虚拟机之后闲没事, 就用这个语言给他自己写了个集成开发环境,基于QT的, IntelliSence(代码提示)不太理想,凑活用吧 以后有时间再搞.

特性介绍:

源文件扩展名: *.xcs

编译器: xlang/bin/xcross 
命令行参数:
	xcross [-lix] [-libpath path..] [-incpath path...] [-lib libs...] -[c|ce|gs|e|cr] intputfile [outputfile|outputdir]

	xcross -c intput output 
	编译为字节码

	xcross -lix -c intput output 
	编译为静态库

	xcross -gs intput outdir 
	生成native的C代码框架

	xcross -cr intput 
	编译并在编译器中运行

	xcross -ce intput output 
	编译为可执行exe文件

	xcross -e intput [args]
	运行字节码文件

	-libpath [path...]
	设置编译器的连接路径

	-lib [lib.lix...]
	设置要链接的静态库

	-incpath [path...]
	设置编译器的inc\require路径

	-nd
	不生成调试信息, 将使生成的文件更小,应用启动速度略微加快,但意味着出现Exception时,无法获得详尽的跟踪信息,
	注:无论生成调试信息与否, 均不会影响运行时性能.


现版本中未提供独立虚拟机.


该语言借鉴了java的部分如下特性:

1.面向对象, (但同时继承了C++的面向过程式开发)

2.支持泛型编程(主要就是模板类,但不支持模板函数, 感觉太乱, 还是不支持的好)

3.支持多态,所有方法均为虚方法,可以在类中声明纯虚函数,或者声明interface类,但不实现肯定是不能通过编译的.

4.支持闭包,是真闭包哦, 没有什么蛋疼的语法,就像java那样使用,(但是java却是假闭包, 只是做了一份copy, 只能用不能改)

5.同样做了package的特性, 虽然好像用处不大,但是我在测试过程中发现a.b.c.d.e.f.g...这种的写法太蛋疼, 还是加个package 然后用using概括一下比较简单.

6.支持多线程.

7.自动的垃圾回收(提供手动gc接口)

8.synchronized块同步语法

9,入口点程序格式:
	int main(String [] args){

	}




该语言借鉴了C++的部分如下特性:

1.include 或者require 包含文件,但不存在头文件之类的, 所有文件都是源文件

2.重载操作符,目前支持 + - / * += -= *= /= == != >> << < > <= >= <<= >>= & | ^ ~ &= |= ^= ,很遗憾没有支持[]操作符.

新的内容:

1.无论class还是interface,都只能单继承, 不允许多重继承.

2.没有enum数据类型(暂时用不到,可能后面考虑添加)

3.增强了native api的功能调用,只需要声明 import "libxxxx" 就可以调用native函数

4.编译源码不用再强调编译或者声明的先后顺序,只要在源码看得到的地方,可以随便调用.
注:虽然编译时不分先后顺序,但是由于static const类型在编译期需要取字面量值做优化,如果不定义在前面的话 仍然是会报错的.

5.支持不同参数的函数重载.

6.synchronized_read \ synchronized_write 块读写同步语法

7.所有的interface都是静态,interface内不可以有变量声明

8.字符串断行不需要用\, 用 + 连接更好(不会产生运行时代码)

9.派生类构造方法中显式调用基类构造方法应放在第一行且仅能调用一次.

10.派生类构造方法(无论是否有参)中若没有显式调用基类构造将隐式调用基类默认构造方法.

11.基类(该类是另一个类的派生类)若无默认构造函数,在派生类构造的时候将跳过基类构造直接调用基类的基类默认构造方法.

12.类中存在有参构造方式且不存在显式默认构造方式时, 将禁用默认构造方法


实现原理介绍.

编译器前端使用LL分析法(自己写的一个LL 分析生成器生成的C++代码).

垃圾回收部分采用引用计数法(当然会消除循环引用).

虚拟机很遗憾没有用C写,用C的话会带来更好的性能体验,但是那将是一个很麻烦的过程.

仅仅对IRcode做了基础的优化,也不会消除无用的代码.

虚拟机指令设计方面采用了寄存器式(register-based)指令系统.

实现流程:
	
	源代码 --> LL LEXER -> AST(抽象语法树) -> AST Optimizer(初步优化,主要是对常量之类的以及可变换的语法) ->Compiler(此处原本应该有个Optimizer的) -> IRCODE (中间码) ->IR Optimizer(主要优化指令结构) -> BYTECODE.

保留关键字(35个):
import  cdecl  stdcall  fastcall pascal operator for while do try catch if break continue
default  interface  class  package  static  const  throw  switch  case  else return  new
include using  require finally final synchronized_read  synchronized_write synchronized
@Declare


运算符优先级:


-------------------------------------------------------------------------------------------------------------
优先级 		操作符		描述				结合方向
-------------------------------------------------------------------------------------------------------------
1		()		调节优先级的括号操作符		从左到右
		[]		数组下标访问操作符
		new{}/[]		创建对象/数组			从右到左
		.		访问成员的操作符			从左到右
		++		后置自增操作符
		--		后置自减操作符
-------------------------------------------------------------------------------------------------------------
2		!		逻辑取反操作符			从右到左
		~		按位取反
		++		前置自增操作符
		--		前置自减操作符
		-		一元取负操作符
-------------------------------------------------------------------------------------------------------------
3		*		乘法操作符			从左到右
		/		除法操作符
		%		取余数操作符
-------------------------------------------------------------------------------------------------------------
4		+		加法操作符			从左到右
		-		减法操作符
-------------------------------------------------------------------------------------------------------------
5		<<		按位左移操作符			从左到右
		>>		按位右移操作符
-------------------------------------------------------------------------------------------------------------
6		<		小于比较操作符			从左到右
		<=		小于或等于比较操作符
		>		大于比较操作符
		>=		大于或等于比较操作符

-------------------------------------------------------------------------------------------------------------
7		==		等于比较操作符			从左到右
		!=		不等于比较操作符
-------------------------------------------------------------------------------------------------------------
8		&		按位与操作符			从左到右
-------------------------------------------------------------------------------------------------------------
9		^		按位异或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
10		|		按位或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
11		&&		逻辑与操作符			从左到右
-------------------------------------------------------------------------------------------------------------
12		||		逻辑或操作符			从左到右
-------------------------------------------------------------------------------------------------------------
13		? :		三元条件操作符			从右到左
-------------------------------------------------------------------------------------------------------------
14		=		赋值操作符			从右到左
		+=		复合赋值操作符(加法)
		-=		复合赋值操作符(减法)
		*=		复合赋值操作符(乘法)
		/=		复合赋值操作符(除法)
		%=		复合赋值操作符(取余)
		&=		复合赋值操作符(按位与)
		^=		复合赋值操作符(按位异或)
		|=		复合赋值操作符(按位或)
		<<=		复合赋值操作符(按位左移)
		>>=		复合赋值操作符(按位右移)
-------------------------------------------------------------------------------------------------------------


语法特性和定义:
new 对象必须为类 或者数组,如new a(), new a[];
class 定义末尾须加分号 如 class a{ ... };
package 定义同class
interface定义同class
Object类型可用于任何类型,需要强转
native定义为	import "模块名"{  native函数列表 };
native函数声明中用到的类型只有int long byte short double String bool Object ObjectPtr 九种类型. ObjectPtr表示取地址, 其他为取对象(String默认取地址)
include和require语法:	include("文件1", "文件2",..."文件N")
using语法:		using{包1; 包2; 包1.小包1;... 包N};
类继承语法:	a继承b	=	class a : b { 	};
final修饰的类不可被继承
const修饰的变量不可被修改
final修饰的函数不可派生类重写
static修饰的对象为静态对象

其他的参照Java语法, 或者C++语法.



语言结构:
1.变量\常量
2.函数
3.类(含模板类)
4.接口
5.包 package
6.native组件



内置对象:

基本类型:
void	无类型

POD类型:
byte	无符号8位整数(0~255)
char	无符号16位整数(0~65535)
short	有符号16位整数(-32768~+32767)
int	有符号32位整数(-2,147,483,648~2,147,483,647)
long	有符号64位整数(-9,223,372,036,854,775,808~9,223,372,036,854,775,807)
double	双精度浮点数类型(1.7E+10-308~1.7E+10+308)
bool	布尔类型(true,false)
String 	字符串类(multibyte characters string)

数组:
[](Array)	数组对象(POD类型的数组为连续的POD类型数组(string除外),其他类型的数组为指针引用)

特殊对象:
System	系统平台相关调用集合
Exception	异常

空指针对象:
nilptr	空指针,可以与任意类进行,但不可以与byte short char int long bool double互相操作

扩展的内置对象:
Thread			线程对象(类),如同java的Thread
Vector			vector容器(模板类)
Map(含Iterator)		基于红黑树的map实现(模板类)
List(含Iterator)		列表容器(模板类)
Pattern(含Result)		正则表达式对象(类)
HttpRequest		http请求操作类(主要依靠第三方libcurl)(类)
Unsi(含Instance类)		通用服务器接口组件(类)
AsyncInput		异步输入接口(接口)
JsonObject		Json对象类
JsonArray			Json数组类
Timer			定时器
TimerTask			定时器任务接口
Window			Windows平台下的窗口类

内置异常类:
DivByZeroException		除零异常
IndexOutOfBoundsException	下标越界异常
ArrayStoreException		数组储存异常
ClassCastException		强制转换异常
IllegalArgumentException	参数异常
NullPointerException	空指针异常
OutOfMemoryException	内存溢出异常(暂无用)
InvalidIteratorException	迭代器失效异常


同名对象选择优先级:
1.栈
2.成员
3.堆和其他

文件夹介绍:
	example		代码用例
	xnl		native C/C++ 调用头文件
	lib		QT的ntive库和静态库
	common		通用的类型定义
	bin		编译器&虚拟机目录


